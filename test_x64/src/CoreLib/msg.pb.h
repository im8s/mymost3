// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_msg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_msg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_msg_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_msg_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_msg_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_msg_2eproto_metadata_getter(int index);
namespace pb {
class PLeaveList;
struct PLeaveListDefaultTypeInternal;
extern PLeaveListDefaultTypeInternal _PLeaveList_default_instance_;
class PlayerInfo;
struct PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class PlayerJoin;
struct PlayerJoinDefaultTypeInternal;
extern PlayerJoinDefaultTypeInternal _PlayerJoin_default_instance_;
class PlayerLeave;
struct PlayerLeaveDefaultTypeInternal;
extern PlayerLeaveDefaultTypeInternal _PlayerLeave_default_instance_;
class PlayerList;
struct PlayerListDefaultTypeInternal;
extern PlayerListDefaultTypeInternal _PlayerList_default_instance_;
class PlayerLogin;
struct PlayerLoginDefaultTypeInternal;
extern PlayerLoginDefaultTypeInternal _PlayerLogin_default_instance_;
class PlayerOther;
struct PlayerOtherDefaultTypeInternal;
extern PlayerOtherDefaultTypeInternal _PlayerOther_default_instance_;
class PlayerReqMsg;
struct PlayerReqMsgDefaultTypeInternal;
extern PlayerReqMsgDefaultTypeInternal _PlayerReqMsg_default_instance_;
class PlayerResMsg;
struct PlayerResMsgDefaultTypeInternal;
extern PlayerResMsgDefaultTypeInternal _PlayerResMsg_default_instance_;
class PlayerState;
struct PlayerStateDefaultTypeInternal;
extern PlayerStateDefaultTypeInternal _PlayerState_default_instance_;
class SysMsg;
struct SysMsgDefaultTypeInternal;
extern SysMsgDefaultTypeInternal _SysMsg_default_instance_;
class TalkMsg;
struct TalkMsgDefaultTypeInternal;
extern TalkMsgDefaultTypeInternal _TalkMsg_default_instance_;
}  // namespace pb
PROTOBUF_NAMESPACE_OPEN
template<> ::pb::PLeaveList* Arena::CreateMaybeMessage<::pb::PLeaveList>(Arena*);
template<> ::pb::PlayerInfo* Arena::CreateMaybeMessage<::pb::PlayerInfo>(Arena*);
template<> ::pb::PlayerJoin* Arena::CreateMaybeMessage<::pb::PlayerJoin>(Arena*);
template<> ::pb::PlayerLeave* Arena::CreateMaybeMessage<::pb::PlayerLeave>(Arena*);
template<> ::pb::PlayerList* Arena::CreateMaybeMessage<::pb::PlayerList>(Arena*);
template<> ::pb::PlayerLogin* Arena::CreateMaybeMessage<::pb::PlayerLogin>(Arena*);
template<> ::pb::PlayerOther* Arena::CreateMaybeMessage<::pb::PlayerOther>(Arena*);
template<> ::pb::PlayerReqMsg* Arena::CreateMaybeMessage<::pb::PlayerReqMsg>(Arena*);
template<> ::pb::PlayerResMsg* Arena::CreateMaybeMessage<::pb::PlayerResMsg>(Arena*);
template<> ::pb::PlayerState* Arena::CreateMaybeMessage<::pb::PlayerState>(Arena*);
template<> ::pb::SysMsg* Arena::CreateMaybeMessage<::pb::SysMsg>(Arena*);
template<> ::pb::TalkMsg* Arena::CreateMaybeMessage<::pb::TalkMsg>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pb {

// ===================================================================

class PlayerState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PlayerState) */ {
 public:
  inline PlayerState() : PlayerState(nullptr) {}
  virtual ~PlayerState();
  explicit constexpr PlayerState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerState(const PlayerState& from);
  PlayerState(PlayerState&& from) noexcept
    : PlayerState() {
    *this = ::std::move(from);
  }

  inline PlayerState& operator=(const PlayerState& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerState& operator=(PlayerState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerState& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerState* internal_default_instance() {
    return reinterpret_cast<const PlayerState*>(
               &_PlayerState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PlayerState& a, PlayerState& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerState* New() const final {
    return CreateMaybeMessage<PlayerState>(nullptr);
  }

  PlayerState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerState& from);
  void MergeFrom(const PlayerState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PlayerState";
  }
  protected:
  explicit PlayerState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_msg_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPIDFieldNumber = 1,
    kTypeFieldNumber = 2,
    kCodeFieldNumber = 3,
  };
  // string PID = 1;
  void clear_pid();
  const std::string& pid() const;
  void set_pid(const std::string& value);
  void set_pid(std::string&& value);
  void set_pid(const char* value);
  void set_pid(const char* value, size_t size);
  std::string* mutable_pid();
  std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // int32 Type = 2;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 Code = 3;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.PlayerState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {}
  virtual ~PlayerInfo();
  explicit constexpr PlayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfo(const PlayerInfo& from);
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerInfo* New() const final {
    return CreateMaybeMessage<PlayerInfo>(nullptr);
  }

  PlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_msg_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPIDFieldNumber = 1,
    kNameFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // string PID = 1;
  void clear_pid();
  const std::string& pid() const;
  void set_pid(const std::string& value);
  void set_pid(std::string&& value);
  void set_pid(const char* value);
  void set_pid(const char* value, size_t size);
  std::string* mutable_pid();
  std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // string Name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 Type = 3;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.PlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class PlayerList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PlayerList) */ {
 public:
  inline PlayerList() : PlayerList(nullptr) {}
  virtual ~PlayerList();
  explicit constexpr PlayerList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerList(const PlayerList& from);
  PlayerList(PlayerList&& from) noexcept
    : PlayerList() {
    *this = ::std::move(from);
  }

  inline PlayerList& operator=(const PlayerList& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerList& operator=(PlayerList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerList& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerList* internal_default_instance() {
    return reinterpret_cast<const PlayerList*>(
               &_PlayerList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PlayerList& a, PlayerList& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerList* New() const final {
    return CreateMaybeMessage<PlayerList>(nullptr);
  }

  PlayerList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerList& from);
  void MergeFrom(const PlayerList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PlayerList";
  }
  protected:
  explicit PlayerList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_msg_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .pb.PlayerInfo Players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::pb::PlayerInfo* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PlayerInfo >*
      mutable_players();
  private:
  const ::pb::PlayerInfo& _internal_players(int index) const;
  ::pb::PlayerInfo* _internal_add_players();
  public:
  const ::pb::PlayerInfo& players(int index) const;
  ::pb::PlayerInfo* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PlayerInfo >&
      players() const;

  // @@protoc_insertion_point(class_scope:pb.PlayerList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PlayerInfo > players_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class PlayerLogin PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PlayerLogin) */ {
 public:
  inline PlayerLogin() : PlayerLogin(nullptr) {}
  virtual ~PlayerLogin();
  explicit constexpr PlayerLogin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerLogin(const PlayerLogin& from);
  PlayerLogin(PlayerLogin&& from) noexcept
    : PlayerLogin() {
    *this = ::std::move(from);
  }

  inline PlayerLogin& operator=(const PlayerLogin& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerLogin& operator=(PlayerLogin&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerLogin& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerLogin* internal_default_instance() {
    return reinterpret_cast<const PlayerLogin*>(
               &_PlayerLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PlayerLogin& a, PlayerLogin& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerLogin* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerLogin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerLogin* New() const final {
    return CreateMaybeMessage<PlayerLogin>(nullptr);
  }

  PlayerLogin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerLogin>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerLogin& from);
  void MergeFrom(const PlayerLogin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerLogin* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PlayerLogin";
  }
  protected:
  explicit PlayerLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_msg_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kPassFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // string Name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string Pass = 2;
  void clear_pass();
  const std::string& pass() const;
  void set_pass(const std::string& value);
  void set_pass(std::string&& value);
  void set_pass(const char* value);
  void set_pass(const char* value, size_t size);
  std::string* mutable_pass();
  std::string* release_pass();
  void set_allocated_pass(std::string* pass);
  private:
  const std::string& _internal_pass() const;
  void _internal_set_pass(const std::string& value);
  std::string* _internal_mutable_pass();
  public:

  // int32 Type = 3;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.PlayerLogin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pass_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class PlayerJoin PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PlayerJoin) */ {
 public:
  inline PlayerJoin() : PlayerJoin(nullptr) {}
  virtual ~PlayerJoin();
  explicit constexpr PlayerJoin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerJoin(const PlayerJoin& from);
  PlayerJoin(PlayerJoin&& from) noexcept
    : PlayerJoin() {
    *this = ::std::move(from);
  }

  inline PlayerJoin& operator=(const PlayerJoin& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerJoin& operator=(PlayerJoin&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerJoin& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerJoin* internal_default_instance() {
    return reinterpret_cast<const PlayerJoin*>(
               &_PlayerJoin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PlayerJoin& a, PlayerJoin& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerJoin* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerJoin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerJoin* New() const final {
    return CreateMaybeMessage<PlayerJoin>(nullptr);
  }

  PlayerJoin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerJoin>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerJoin& from);
  void MergeFrom(const PlayerJoin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerJoin* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PlayerJoin";
  }
  protected:
  explicit PlayerJoin(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_msg_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPInfoFieldNumber = 1,
  };
  // .pb.PlayerInfo PInfo = 1;
  bool has_pinfo() const;
  private:
  bool _internal_has_pinfo() const;
  public:
  void clear_pinfo();
  const ::pb::PlayerInfo& pinfo() const;
  ::pb::PlayerInfo* release_pinfo();
  ::pb::PlayerInfo* mutable_pinfo();
  void set_allocated_pinfo(::pb::PlayerInfo* pinfo);
  private:
  const ::pb::PlayerInfo& _internal_pinfo() const;
  ::pb::PlayerInfo* _internal_mutable_pinfo();
  public:
  void unsafe_arena_set_allocated_pinfo(
      ::pb::PlayerInfo* pinfo);
  ::pb::PlayerInfo* unsafe_arena_release_pinfo();

  // @@protoc_insertion_point(class_scope:pb.PlayerJoin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pb::PlayerInfo* pinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class PlayerLeave PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PlayerLeave) */ {
 public:
  inline PlayerLeave() : PlayerLeave(nullptr) {}
  virtual ~PlayerLeave();
  explicit constexpr PlayerLeave(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerLeave(const PlayerLeave& from);
  PlayerLeave(PlayerLeave&& from) noexcept
    : PlayerLeave() {
    *this = ::std::move(from);
  }

  inline PlayerLeave& operator=(const PlayerLeave& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerLeave& operator=(PlayerLeave&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerLeave& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerLeave* internal_default_instance() {
    return reinterpret_cast<const PlayerLeave*>(
               &_PlayerLeave_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PlayerLeave& a, PlayerLeave& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerLeave* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerLeave* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerLeave* New() const final {
    return CreateMaybeMessage<PlayerLeave>(nullptr);
  }

  PlayerLeave* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerLeave>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerLeave& from);
  void MergeFrom(const PlayerLeave& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerLeave* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PlayerLeave";
  }
  protected:
  explicit PlayerLeave(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_msg_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPIDFieldNumber = 1,
    kReasonFieldNumber = 2,
  };
  // string PID = 1;
  void clear_pid();
  const std::string& pid() const;
  void set_pid(const std::string& value);
  void set_pid(std::string&& value);
  void set_pid(const char* value);
  void set_pid(const char* value, size_t size);
  std::string* mutable_pid();
  std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // int32 Reason = 2;
  void clear_reason();
  ::PROTOBUF_NAMESPACE_ID::int32 reason() const;
  void set_reason(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_reason() const;
  void _internal_set_reason(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.PlayerLeave)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
  ::PROTOBUF_NAMESPACE_ID::int32 reason_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class PLeaveList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PLeaveList) */ {
 public:
  inline PLeaveList() : PLeaveList(nullptr) {}
  virtual ~PLeaveList();
  explicit constexpr PLeaveList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PLeaveList(const PLeaveList& from);
  PLeaveList(PLeaveList&& from) noexcept
    : PLeaveList() {
    *this = ::std::move(from);
  }

  inline PLeaveList& operator=(const PLeaveList& from) {
    CopyFrom(from);
    return *this;
  }
  inline PLeaveList& operator=(PLeaveList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PLeaveList& default_instance() {
    return *internal_default_instance();
  }
  static inline const PLeaveList* internal_default_instance() {
    return reinterpret_cast<const PLeaveList*>(
               &_PLeaveList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PLeaveList& a, PLeaveList& b) {
    a.Swap(&b);
  }
  inline void Swap(PLeaveList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PLeaveList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PLeaveList* New() const final {
    return CreateMaybeMessage<PLeaveList>(nullptr);
  }

  PLeaveList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PLeaveList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PLeaveList& from);
  void MergeFrom(const PLeaveList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PLeaveList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PLeaveList";
  }
  protected:
  explicit PLeaveList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_msg_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPLeavesFieldNumber = 1,
  };
  // repeated .pb.PlayerLeave PLeaves = 1;
  int pleaves_size() const;
  private:
  int _internal_pleaves_size() const;
  public:
  void clear_pleaves();
  ::pb::PlayerLeave* mutable_pleaves(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PlayerLeave >*
      mutable_pleaves();
  private:
  const ::pb::PlayerLeave& _internal_pleaves(int index) const;
  ::pb::PlayerLeave* _internal_add_pleaves();
  public:
  const ::pb::PlayerLeave& pleaves(int index) const;
  ::pb::PlayerLeave* add_pleaves();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PlayerLeave >&
      pleaves() const;

  // @@protoc_insertion_point(class_scope:pb.PLeaveList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PlayerLeave > pleaves_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class PlayerOther PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PlayerOther) */ {
 public:
  inline PlayerOther() : PlayerOther(nullptr) {}
  virtual ~PlayerOther();
  explicit constexpr PlayerOther(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerOther(const PlayerOther& from);
  PlayerOther(PlayerOther&& from) noexcept
    : PlayerOther() {
    *this = ::std::move(from);
  }

  inline PlayerOther& operator=(const PlayerOther& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerOther& operator=(PlayerOther&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerOther& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerOther* internal_default_instance() {
    return reinterpret_cast<const PlayerOther*>(
               &_PlayerOther_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PlayerOther& a, PlayerOther& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerOther* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerOther* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerOther* New() const final {
    return CreateMaybeMessage<PlayerOther>(nullptr);
  }

  PlayerOther* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerOther>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerOther& from);
  void MergeFrom(const PlayerOther& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerOther* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PlayerOther";
  }
  protected:
  explicit PlayerOther(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_msg_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRTypeFieldNumber = 1,
  };
  // int32 RType = 1;
  void clear_rtype();
  ::PROTOBUF_NAMESPACE_ID::int32 rtype() const;
  void set_rtype(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rtype() const;
  void _internal_set_rtype(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.PlayerOther)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 rtype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class PlayerReqMsg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PlayerReqMsg) */ {
 public:
  inline PlayerReqMsg() : PlayerReqMsg(nullptr) {}
  virtual ~PlayerReqMsg();
  explicit constexpr PlayerReqMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerReqMsg(const PlayerReqMsg& from);
  PlayerReqMsg(PlayerReqMsg&& from) noexcept
    : PlayerReqMsg() {
    *this = ::std::move(from);
  }

  inline PlayerReqMsg& operator=(const PlayerReqMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerReqMsg& operator=(PlayerReqMsg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerReqMsg& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kPLogin = 2,
    kPJoin = 3,
    kPLeave = 4,
    kPOther = 5,
    DATA_NOT_SET = 0,
  };

  static inline const PlayerReqMsg* internal_default_instance() {
    return reinterpret_cast<const PlayerReqMsg*>(
               &_PlayerReqMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PlayerReqMsg& a, PlayerReqMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerReqMsg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerReqMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerReqMsg* New() const final {
    return CreateMaybeMessage<PlayerReqMsg>(nullptr);
  }

  PlayerReqMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerReqMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerReqMsg& from);
  void MergeFrom(const PlayerReqMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerReqMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PlayerReqMsg";
  }
  protected:
  explicit PlayerReqMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_msg_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPIDFieldNumber = 1,
    kPLoginFieldNumber = 2,
    kPJoinFieldNumber = 3,
    kPLeaveFieldNumber = 4,
    kPOtherFieldNumber = 5,
  };
  // string PID = 1;
  void clear_pid();
  const std::string& pid() const;
  void set_pid(const std::string& value);
  void set_pid(std::string&& value);
  void set_pid(const char* value);
  void set_pid(const char* value, size_t size);
  std::string* mutable_pid();
  std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // .pb.PlayerLogin PLogin = 2;
  bool has_plogin() const;
  private:
  bool _internal_has_plogin() const;
  public:
  void clear_plogin();
  const ::pb::PlayerLogin& plogin() const;
  ::pb::PlayerLogin* release_plogin();
  ::pb::PlayerLogin* mutable_plogin();
  void set_allocated_plogin(::pb::PlayerLogin* plogin);
  private:
  const ::pb::PlayerLogin& _internal_plogin() const;
  ::pb::PlayerLogin* _internal_mutable_plogin();
  public:
  void unsafe_arena_set_allocated_plogin(
      ::pb::PlayerLogin* plogin);
  ::pb::PlayerLogin* unsafe_arena_release_plogin();

  // .pb.PlayerJoin PJoin = 3;
  bool has_pjoin() const;
  private:
  bool _internal_has_pjoin() const;
  public:
  void clear_pjoin();
  const ::pb::PlayerJoin& pjoin() const;
  ::pb::PlayerJoin* release_pjoin();
  ::pb::PlayerJoin* mutable_pjoin();
  void set_allocated_pjoin(::pb::PlayerJoin* pjoin);
  private:
  const ::pb::PlayerJoin& _internal_pjoin() const;
  ::pb::PlayerJoin* _internal_mutable_pjoin();
  public:
  void unsafe_arena_set_allocated_pjoin(
      ::pb::PlayerJoin* pjoin);
  ::pb::PlayerJoin* unsafe_arena_release_pjoin();

  // .pb.PlayerLeave PLeave = 4;
  bool has_pleave() const;
  private:
  bool _internal_has_pleave() const;
  public:
  void clear_pleave();
  const ::pb::PlayerLeave& pleave() const;
  ::pb::PlayerLeave* release_pleave();
  ::pb::PlayerLeave* mutable_pleave();
  void set_allocated_pleave(::pb::PlayerLeave* pleave);
  private:
  const ::pb::PlayerLeave& _internal_pleave() const;
  ::pb::PlayerLeave* _internal_mutable_pleave();
  public:
  void unsafe_arena_set_allocated_pleave(
      ::pb::PlayerLeave* pleave);
  ::pb::PlayerLeave* unsafe_arena_release_pleave();

  // .pb.PlayerOther POther = 5;
  bool has_pother() const;
  private:
  bool _internal_has_pother() const;
  public:
  void clear_pother();
  const ::pb::PlayerOther& pother() const;
  ::pb::PlayerOther* release_pother();
  ::pb::PlayerOther* mutable_pother();
  void set_allocated_pother(::pb::PlayerOther* pother);
  private:
  const ::pb::PlayerOther& _internal_pother() const;
  ::pb::PlayerOther* _internal_mutable_pother();
  public:
  void unsafe_arena_set_allocated_pother(
      ::pb::PlayerOther* pother);
  ::pb::PlayerOther* unsafe_arena_release_pother();

  void clear_Data();
  DataCase Data_case() const;
  // @@protoc_insertion_point(class_scope:pb.PlayerReqMsg)
 private:
  class _Internal;
  void set_has_plogin();
  void set_has_pjoin();
  void set_has_pleave();
  void set_has_pother();

  inline bool has_Data() const;
  inline void clear_has_Data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
  union DataUnion {
    constexpr DataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::pb::PlayerLogin* plogin_;
    ::pb::PlayerJoin* pjoin_;
    ::pb::PlayerLeave* pleave_;
    ::pb::PlayerOther* pother_;
  } Data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class PlayerResMsg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.PlayerResMsg) */ {
 public:
  inline PlayerResMsg() : PlayerResMsg(nullptr) {}
  virtual ~PlayerResMsg();
  explicit constexpr PlayerResMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerResMsg(const PlayerResMsg& from);
  PlayerResMsg(PlayerResMsg&& from) noexcept
    : PlayerResMsg() {
    *this = ::std::move(from);
  }

  inline PlayerResMsg& operator=(const PlayerResMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerResMsg& operator=(PlayerResMsg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlayerResMsg& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kPStatus = 2,
    kPInfo = 3,
    kPList = 4,
    kPJoin = 5,
    kPLeave = 6,
    kPLList = 7,
    DATA_NOT_SET = 0,
  };

  static inline const PlayerResMsg* internal_default_instance() {
    return reinterpret_cast<const PlayerResMsg*>(
               &_PlayerResMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(PlayerResMsg& a, PlayerResMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerResMsg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerResMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlayerResMsg* New() const final {
    return CreateMaybeMessage<PlayerResMsg>(nullptr);
  }

  PlayerResMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlayerResMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlayerResMsg& from);
  void MergeFrom(const PlayerResMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerResMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.PlayerResMsg";
  }
  protected:
  explicit PlayerResMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_msg_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPIDFieldNumber = 1,
    kPStatusFieldNumber = 2,
    kPInfoFieldNumber = 3,
    kPListFieldNumber = 4,
    kPJoinFieldNumber = 5,
    kPLeaveFieldNumber = 6,
    kPLListFieldNumber = 7,
  };
  // string PID = 1;
  void clear_pid();
  const std::string& pid() const;
  void set_pid(const std::string& value);
  void set_pid(std::string&& value);
  void set_pid(const char* value);
  void set_pid(const char* value, size_t size);
  std::string* mutable_pid();
  std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // .pb.PlayerState PStatus = 2;
  bool has_pstatus() const;
  private:
  bool _internal_has_pstatus() const;
  public:
  void clear_pstatus();
  const ::pb::PlayerState& pstatus() const;
  ::pb::PlayerState* release_pstatus();
  ::pb::PlayerState* mutable_pstatus();
  void set_allocated_pstatus(::pb::PlayerState* pstatus);
  private:
  const ::pb::PlayerState& _internal_pstatus() const;
  ::pb::PlayerState* _internal_mutable_pstatus();
  public:
  void unsafe_arena_set_allocated_pstatus(
      ::pb::PlayerState* pstatus);
  ::pb::PlayerState* unsafe_arena_release_pstatus();

  // .pb.PlayerInfo PInfo = 3;
  bool has_pinfo() const;
  private:
  bool _internal_has_pinfo() const;
  public:
  void clear_pinfo();
  const ::pb::PlayerInfo& pinfo() const;
  ::pb::PlayerInfo* release_pinfo();
  ::pb::PlayerInfo* mutable_pinfo();
  void set_allocated_pinfo(::pb::PlayerInfo* pinfo);
  private:
  const ::pb::PlayerInfo& _internal_pinfo() const;
  ::pb::PlayerInfo* _internal_mutable_pinfo();
  public:
  void unsafe_arena_set_allocated_pinfo(
      ::pb::PlayerInfo* pinfo);
  ::pb::PlayerInfo* unsafe_arena_release_pinfo();

  // .pb.PlayerList PList = 4;
  bool has_plist() const;
  private:
  bool _internal_has_plist() const;
  public:
  void clear_plist();
  const ::pb::PlayerList& plist() const;
  ::pb::PlayerList* release_plist();
  ::pb::PlayerList* mutable_plist();
  void set_allocated_plist(::pb::PlayerList* plist);
  private:
  const ::pb::PlayerList& _internal_plist() const;
  ::pb::PlayerList* _internal_mutable_plist();
  public:
  void unsafe_arena_set_allocated_plist(
      ::pb::PlayerList* plist);
  ::pb::PlayerList* unsafe_arena_release_plist();

  // .pb.PlayerJoin PJoin = 5;
  bool has_pjoin() const;
  private:
  bool _internal_has_pjoin() const;
  public:
  void clear_pjoin();
  const ::pb::PlayerJoin& pjoin() const;
  ::pb::PlayerJoin* release_pjoin();
  ::pb::PlayerJoin* mutable_pjoin();
  void set_allocated_pjoin(::pb::PlayerJoin* pjoin);
  private:
  const ::pb::PlayerJoin& _internal_pjoin() const;
  ::pb::PlayerJoin* _internal_mutable_pjoin();
  public:
  void unsafe_arena_set_allocated_pjoin(
      ::pb::PlayerJoin* pjoin);
  ::pb::PlayerJoin* unsafe_arena_release_pjoin();

  // .pb.PlayerLeave PLeave = 6;
  bool has_pleave() const;
  private:
  bool _internal_has_pleave() const;
  public:
  void clear_pleave();
  const ::pb::PlayerLeave& pleave() const;
  ::pb::PlayerLeave* release_pleave();
  ::pb::PlayerLeave* mutable_pleave();
  void set_allocated_pleave(::pb::PlayerLeave* pleave);
  private:
  const ::pb::PlayerLeave& _internal_pleave() const;
  ::pb::PlayerLeave* _internal_mutable_pleave();
  public:
  void unsafe_arena_set_allocated_pleave(
      ::pb::PlayerLeave* pleave);
  ::pb::PlayerLeave* unsafe_arena_release_pleave();

  // .pb.PLeaveList PLList = 7;
  bool has_pllist() const;
  private:
  bool _internal_has_pllist() const;
  public:
  void clear_pllist();
  const ::pb::PLeaveList& pllist() const;
  ::pb::PLeaveList* release_pllist();
  ::pb::PLeaveList* mutable_pllist();
  void set_allocated_pllist(::pb::PLeaveList* pllist);
  private:
  const ::pb::PLeaveList& _internal_pllist() const;
  ::pb::PLeaveList* _internal_mutable_pllist();
  public:
  void unsafe_arena_set_allocated_pllist(
      ::pb::PLeaveList* pllist);
  ::pb::PLeaveList* unsafe_arena_release_pllist();

  void clear_Data();
  DataCase Data_case() const;
  // @@protoc_insertion_point(class_scope:pb.PlayerResMsg)
 private:
  class _Internal;
  void set_has_pstatus();
  void set_has_pinfo();
  void set_has_plist();
  void set_has_pjoin();
  void set_has_pleave();
  void set_has_pllist();

  inline bool has_Data() const;
  inline void clear_has_Data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
  union DataUnion {
    constexpr DataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::pb::PlayerState* pstatus_;
    ::pb::PlayerInfo* pinfo_;
    ::pb::PlayerList* plist_;
    ::pb::PlayerJoin* pjoin_;
    ::pb::PlayerLeave* pleave_;
    ::pb::PLeaveList* pllist_;
  } Data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class SysMsg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.SysMsg) */ {
 public:
  inline SysMsg() : SysMsg(nullptr) {}
  virtual ~SysMsg();
  explicit constexpr SysMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SysMsg(const SysMsg& from);
  SysMsg(SysMsg&& from) noexcept
    : SysMsg() {
    *this = ::std::move(from);
  }

  inline SysMsg& operator=(const SysMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SysMsg& operator=(SysMsg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SysMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SysMsg* internal_default_instance() {
    return reinterpret_cast<const SysMsg*>(
               &_SysMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SysMsg& a, SysMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SysMsg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SysMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SysMsg* New() const final {
    return CreateMaybeMessage<SysMsg>(nullptr);
  }

  SysMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SysMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SysMsg& from);
  void MergeFrom(const SysMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SysMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.SysMsg";
  }
  protected:
  explicit SysMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_msg_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPIDFieldNumber = 1,
    kContentFieldNumber = 2,
  };
  // string PID = 1;
  void clear_pid();
  const std::string& pid() const;
  void set_pid(const std::string& value);
  void set_pid(std::string&& value);
  void set_pid(const char* value);
  void set_pid(const char* value, size_t size);
  std::string* mutable_pid();
  std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // string Content = 2;
  void clear_content();
  const std::string& content() const;
  void set_content(const std::string& value);
  void set_content(std::string&& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  std::string* mutable_content();
  std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:pb.SysMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// -------------------------------------------------------------------

class TalkMsg PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.TalkMsg) */ {
 public:
  inline TalkMsg() : TalkMsg(nullptr) {}
  virtual ~TalkMsg();
  explicit constexpr TalkMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TalkMsg(const TalkMsg& from);
  TalkMsg(TalkMsg&& from) noexcept
    : TalkMsg() {
    *this = ::std::move(from);
  }

  inline TalkMsg& operator=(const TalkMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline TalkMsg& operator=(TalkMsg&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TalkMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const TalkMsg* internal_default_instance() {
    return reinterpret_cast<const TalkMsg*>(
               &_TalkMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TalkMsg& a, TalkMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(TalkMsg* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TalkMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TalkMsg* New() const final {
    return CreateMaybeMessage<TalkMsg>(nullptr);
  }

  TalkMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TalkMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TalkMsg& from);
  void MergeFrom(const TalkMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TalkMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.TalkMsg";
  }
  protected:
  explicit TalkMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_msg_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPIDFieldNumber = 1,
    kContentFieldNumber = 2,
  };
  // string PID = 1;
  void clear_pid();
  const std::string& pid() const;
  void set_pid(const std::string& value);
  void set_pid(std::string&& value);
  void set_pid(const char* value);
  void set_pid(const char* value, size_t size);
  std::string* mutable_pid();
  std::string* release_pid();
  void set_allocated_pid(std::string* pid);
  private:
  const std::string& _internal_pid() const;
  void _internal_set_pid(const std::string& value);
  std::string* _internal_mutable_pid();
  public:

  // string Content = 2;
  void clear_content();
  const std::string& content() const;
  void set_content(const std::string& value);
  void set_content(std::string&& value);
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  std::string* mutable_content();
  std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:pb.TalkMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_msg_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PlayerState

// string PID = 1;
inline void PlayerState::clear_pid() {
  pid_.ClearToEmpty();
}
inline const std::string& PlayerState::pid() const {
  // @@protoc_insertion_point(field_get:pb.PlayerState.PID)
  return _internal_pid();
}
inline void PlayerState::set_pid(const std::string& value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:pb.PlayerState.PID)
}
inline std::string* PlayerState::mutable_pid() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerState.PID)
  return _internal_mutable_pid();
}
inline const std::string& PlayerState::_internal_pid() const {
  return pid_.Get();
}
inline void PlayerState::_internal_set_pid(const std::string& value) {
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PlayerState::set_pid(std::string&& value) {
  
  pid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.PlayerState.PID)
}
inline void PlayerState::set_pid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.PlayerState.PID)
}
inline void PlayerState::set_pid(const char* value,
    size_t size) {
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.PlayerState.PID)
}
inline std::string* PlayerState::_internal_mutable_pid() {
  
  return pid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PlayerState::release_pid() {
  // @@protoc_insertion_point(field_release:pb.PlayerState.PID)
  return pid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerState::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  pid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.PlayerState.PID)
}

// int32 Type = 2;
inline void PlayerState::clear_type() {
  type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerState::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerState::type() const {
  // @@protoc_insertion_point(field_get:pb.PlayerState.Type)
  return _internal_type();
}
inline void PlayerState::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  type_ = value;
}
inline void PlayerState::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.PlayerState.Type)
}

// int32 Code = 3;
inline void PlayerState::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerState::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerState::code() const {
  // @@protoc_insertion_point(field_get:pb.PlayerState.Code)
  return _internal_code();
}
inline void PlayerState::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void PlayerState::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:pb.PlayerState.Code)
}

// -------------------------------------------------------------------

// PlayerInfo

// string PID = 1;
inline void PlayerInfo::clear_pid() {
  pid_.ClearToEmpty();
}
inline const std::string& PlayerInfo::pid() const {
  // @@protoc_insertion_point(field_get:pb.PlayerInfo.PID)
  return _internal_pid();
}
inline void PlayerInfo::set_pid(const std::string& value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:pb.PlayerInfo.PID)
}
inline std::string* PlayerInfo::mutable_pid() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerInfo.PID)
  return _internal_mutable_pid();
}
inline const std::string& PlayerInfo::_internal_pid() const {
  return pid_.Get();
}
inline void PlayerInfo::_internal_set_pid(const std::string& value) {
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PlayerInfo::set_pid(std::string&& value) {
  
  pid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.PlayerInfo.PID)
}
inline void PlayerInfo::set_pid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.PlayerInfo.PID)
}
inline void PlayerInfo::set_pid(const char* value,
    size_t size) {
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.PlayerInfo.PID)
}
inline std::string* PlayerInfo::_internal_mutable_pid() {
  
  return pid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PlayerInfo::release_pid() {
  // @@protoc_insertion_point(field_release:pb.PlayerInfo.PID)
  return pid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerInfo::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  pid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.PlayerInfo.PID)
}

// string Name = 2;
inline void PlayerInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& PlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:pb.PlayerInfo.Name)
  return _internal_name();
}
inline void PlayerInfo::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:pb.PlayerInfo.Name)
}
inline std::string* PlayerInfo::mutable_name() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerInfo.Name)
  return _internal_mutable_name();
}
inline const std::string& PlayerInfo::_internal_name() const {
  return name_.Get();
}
inline void PlayerInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PlayerInfo::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.PlayerInfo.Name)
}
inline void PlayerInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.PlayerInfo.Name)
}
inline void PlayerInfo::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.PlayerInfo.Name)
}
inline std::string* PlayerInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PlayerInfo::release_name() {
  // @@protoc_insertion_point(field_release:pb.PlayerInfo.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.PlayerInfo.Name)
}

// int32 Type = 3;
inline void PlayerInfo::clear_type() {
  type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfo::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerInfo::type() const {
  // @@protoc_insertion_point(field_get:pb.PlayerInfo.Type)
  return _internal_type();
}
inline void PlayerInfo::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  type_ = value;
}
inline void PlayerInfo::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.PlayerInfo.Type)
}

// -------------------------------------------------------------------

// PlayerList

// repeated .pb.PlayerInfo Players = 1;
inline int PlayerList::_internal_players_size() const {
  return players_.size();
}
inline int PlayerList::players_size() const {
  return _internal_players_size();
}
inline void PlayerList::clear_players() {
  players_.Clear();
}
inline ::pb::PlayerInfo* PlayerList::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:pb.PlayerList.Players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PlayerInfo >*
PlayerList::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:pb.PlayerList.Players)
  return &players_;
}
inline const ::pb::PlayerInfo& PlayerList::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::pb::PlayerInfo& PlayerList::players(int index) const {
  // @@protoc_insertion_point(field_get:pb.PlayerList.Players)
  return _internal_players(index);
}
inline ::pb::PlayerInfo* PlayerList::_internal_add_players() {
  return players_.Add();
}
inline ::pb::PlayerInfo* PlayerList::add_players() {
  // @@protoc_insertion_point(field_add:pb.PlayerList.Players)
  return _internal_add_players();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PlayerInfo >&
PlayerList::players() const {
  // @@protoc_insertion_point(field_list:pb.PlayerList.Players)
  return players_;
}

// -------------------------------------------------------------------

// PlayerLogin

// string Name = 1;
inline void PlayerLogin::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& PlayerLogin::name() const {
  // @@protoc_insertion_point(field_get:pb.PlayerLogin.Name)
  return _internal_name();
}
inline void PlayerLogin::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:pb.PlayerLogin.Name)
}
inline std::string* PlayerLogin::mutable_name() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerLogin.Name)
  return _internal_mutable_name();
}
inline const std::string& PlayerLogin::_internal_name() const {
  return name_.Get();
}
inline void PlayerLogin::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PlayerLogin::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.PlayerLogin.Name)
}
inline void PlayerLogin::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.PlayerLogin.Name)
}
inline void PlayerLogin::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.PlayerLogin.Name)
}
inline std::string* PlayerLogin::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PlayerLogin::release_name() {
  // @@protoc_insertion_point(field_release:pb.PlayerLogin.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerLogin::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.PlayerLogin.Name)
}

// string Pass = 2;
inline void PlayerLogin::clear_pass() {
  pass_.ClearToEmpty();
}
inline const std::string& PlayerLogin::pass() const {
  // @@protoc_insertion_point(field_get:pb.PlayerLogin.Pass)
  return _internal_pass();
}
inline void PlayerLogin::set_pass(const std::string& value) {
  _internal_set_pass(value);
  // @@protoc_insertion_point(field_set:pb.PlayerLogin.Pass)
}
inline std::string* PlayerLogin::mutable_pass() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerLogin.Pass)
  return _internal_mutable_pass();
}
inline const std::string& PlayerLogin::_internal_pass() const {
  return pass_.Get();
}
inline void PlayerLogin::_internal_set_pass(const std::string& value) {
  
  pass_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PlayerLogin::set_pass(std::string&& value) {
  
  pass_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.PlayerLogin.Pass)
}
inline void PlayerLogin::set_pass(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pass_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.PlayerLogin.Pass)
}
inline void PlayerLogin::set_pass(const char* value,
    size_t size) {
  
  pass_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.PlayerLogin.Pass)
}
inline std::string* PlayerLogin::_internal_mutable_pass() {
  
  return pass_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PlayerLogin::release_pass() {
  // @@protoc_insertion_point(field_release:pb.PlayerLogin.Pass)
  return pass_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerLogin::set_allocated_pass(std::string* pass) {
  if (pass != nullptr) {
    
  } else {
    
  }
  pass_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pass,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.PlayerLogin.Pass)
}

// int32 Type = 3;
inline void PlayerLogin::clear_type() {
  type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerLogin::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerLogin::type() const {
  // @@protoc_insertion_point(field_get:pb.PlayerLogin.Type)
  return _internal_type();
}
inline void PlayerLogin::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  type_ = value;
}
inline void PlayerLogin::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.PlayerLogin.Type)
}

// -------------------------------------------------------------------

// PlayerJoin

// .pb.PlayerInfo PInfo = 1;
inline bool PlayerJoin::_internal_has_pinfo() const {
  return this != internal_default_instance() && pinfo_ != nullptr;
}
inline bool PlayerJoin::has_pinfo() const {
  return _internal_has_pinfo();
}
inline void PlayerJoin::clear_pinfo() {
  if (GetArena() == nullptr && pinfo_ != nullptr) {
    delete pinfo_;
  }
  pinfo_ = nullptr;
}
inline const ::pb::PlayerInfo& PlayerJoin::_internal_pinfo() const {
  const ::pb::PlayerInfo* p = pinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::PlayerInfo&>(
      ::pb::_PlayerInfo_default_instance_);
}
inline const ::pb::PlayerInfo& PlayerJoin::pinfo() const {
  // @@protoc_insertion_point(field_get:pb.PlayerJoin.PInfo)
  return _internal_pinfo();
}
inline void PlayerJoin::unsafe_arena_set_allocated_pinfo(
    ::pb::PlayerInfo* pinfo) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pinfo_);
  }
  pinfo_ = pinfo;
  if (pinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.PlayerJoin.PInfo)
}
inline ::pb::PlayerInfo* PlayerJoin::release_pinfo() {
  
  ::pb::PlayerInfo* temp = pinfo_;
  pinfo_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::PlayerInfo* PlayerJoin::unsafe_arena_release_pinfo() {
  // @@protoc_insertion_point(field_release:pb.PlayerJoin.PInfo)
  
  ::pb::PlayerInfo* temp = pinfo_;
  pinfo_ = nullptr;
  return temp;
}
inline ::pb::PlayerInfo* PlayerJoin::_internal_mutable_pinfo() {
  
  if (pinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::PlayerInfo>(GetArena());
    pinfo_ = p;
  }
  return pinfo_;
}
inline ::pb::PlayerInfo* PlayerJoin::mutable_pinfo() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerJoin.PInfo)
  return _internal_mutable_pinfo();
}
inline void PlayerJoin::set_allocated_pinfo(::pb::PlayerInfo* pinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pinfo_;
  }
  if (pinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pinfo);
    if (message_arena != submessage_arena) {
      pinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pinfo, submessage_arena);
    }
    
  } else {
    
  }
  pinfo_ = pinfo;
  // @@protoc_insertion_point(field_set_allocated:pb.PlayerJoin.PInfo)
}

// -------------------------------------------------------------------

// PlayerLeave

// string PID = 1;
inline void PlayerLeave::clear_pid() {
  pid_.ClearToEmpty();
}
inline const std::string& PlayerLeave::pid() const {
  // @@protoc_insertion_point(field_get:pb.PlayerLeave.PID)
  return _internal_pid();
}
inline void PlayerLeave::set_pid(const std::string& value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:pb.PlayerLeave.PID)
}
inline std::string* PlayerLeave::mutable_pid() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerLeave.PID)
  return _internal_mutable_pid();
}
inline const std::string& PlayerLeave::_internal_pid() const {
  return pid_.Get();
}
inline void PlayerLeave::_internal_set_pid(const std::string& value) {
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PlayerLeave::set_pid(std::string&& value) {
  
  pid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.PlayerLeave.PID)
}
inline void PlayerLeave::set_pid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.PlayerLeave.PID)
}
inline void PlayerLeave::set_pid(const char* value,
    size_t size) {
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.PlayerLeave.PID)
}
inline std::string* PlayerLeave::_internal_mutable_pid() {
  
  return pid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PlayerLeave::release_pid() {
  // @@protoc_insertion_point(field_release:pb.PlayerLeave.PID)
  return pid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerLeave::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  pid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.PlayerLeave.PID)
}

// int32 Reason = 2;
inline void PlayerLeave::clear_reason() {
  reason_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerLeave::_internal_reason() const {
  return reason_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerLeave::reason() const {
  // @@protoc_insertion_point(field_get:pb.PlayerLeave.Reason)
  return _internal_reason();
}
inline void PlayerLeave::_internal_set_reason(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  reason_ = value;
}
inline void PlayerLeave::set_reason(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_reason(value);
  // @@protoc_insertion_point(field_set:pb.PlayerLeave.Reason)
}

// -------------------------------------------------------------------

// PLeaveList

// repeated .pb.PlayerLeave PLeaves = 1;
inline int PLeaveList::_internal_pleaves_size() const {
  return pleaves_.size();
}
inline int PLeaveList::pleaves_size() const {
  return _internal_pleaves_size();
}
inline void PLeaveList::clear_pleaves() {
  pleaves_.Clear();
}
inline ::pb::PlayerLeave* PLeaveList::mutable_pleaves(int index) {
  // @@protoc_insertion_point(field_mutable:pb.PLeaveList.PLeaves)
  return pleaves_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PlayerLeave >*
PLeaveList::mutable_pleaves() {
  // @@protoc_insertion_point(field_mutable_list:pb.PLeaveList.PLeaves)
  return &pleaves_;
}
inline const ::pb::PlayerLeave& PLeaveList::_internal_pleaves(int index) const {
  return pleaves_.Get(index);
}
inline const ::pb::PlayerLeave& PLeaveList::pleaves(int index) const {
  // @@protoc_insertion_point(field_get:pb.PLeaveList.PLeaves)
  return _internal_pleaves(index);
}
inline ::pb::PlayerLeave* PLeaveList::_internal_add_pleaves() {
  return pleaves_.Add();
}
inline ::pb::PlayerLeave* PLeaveList::add_pleaves() {
  // @@protoc_insertion_point(field_add:pb.PLeaveList.PLeaves)
  return _internal_add_pleaves();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::PlayerLeave >&
PLeaveList::pleaves() const {
  // @@protoc_insertion_point(field_list:pb.PLeaveList.PLeaves)
  return pleaves_;
}

// -------------------------------------------------------------------

// PlayerOther

// int32 RType = 1;
inline void PlayerOther::clear_rtype() {
  rtype_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerOther::_internal_rtype() const {
  return rtype_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PlayerOther::rtype() const {
  // @@protoc_insertion_point(field_get:pb.PlayerOther.RType)
  return _internal_rtype();
}
inline void PlayerOther::_internal_set_rtype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rtype_ = value;
}
inline void PlayerOther::set_rtype(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rtype(value);
  // @@protoc_insertion_point(field_set:pb.PlayerOther.RType)
}

// -------------------------------------------------------------------

// PlayerReqMsg

// string PID = 1;
inline void PlayerReqMsg::clear_pid() {
  pid_.ClearToEmpty();
}
inline const std::string& PlayerReqMsg::pid() const {
  // @@protoc_insertion_point(field_get:pb.PlayerReqMsg.PID)
  return _internal_pid();
}
inline void PlayerReqMsg::set_pid(const std::string& value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:pb.PlayerReqMsg.PID)
}
inline std::string* PlayerReqMsg::mutable_pid() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerReqMsg.PID)
  return _internal_mutable_pid();
}
inline const std::string& PlayerReqMsg::_internal_pid() const {
  return pid_.Get();
}
inline void PlayerReqMsg::_internal_set_pid(const std::string& value) {
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PlayerReqMsg::set_pid(std::string&& value) {
  
  pid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.PlayerReqMsg.PID)
}
inline void PlayerReqMsg::set_pid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.PlayerReqMsg.PID)
}
inline void PlayerReqMsg::set_pid(const char* value,
    size_t size) {
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.PlayerReqMsg.PID)
}
inline std::string* PlayerReqMsg::_internal_mutable_pid() {
  
  return pid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PlayerReqMsg::release_pid() {
  // @@protoc_insertion_point(field_release:pb.PlayerReqMsg.PID)
  return pid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerReqMsg::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  pid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.PlayerReqMsg.PID)
}

// .pb.PlayerLogin PLogin = 2;
inline bool PlayerReqMsg::_internal_has_plogin() const {
  return Data_case() == kPLogin;
}
inline bool PlayerReqMsg::has_plogin() const {
  return _internal_has_plogin();
}
inline void PlayerReqMsg::set_has_plogin() {
  _oneof_case_[0] = kPLogin;
}
inline void PlayerReqMsg::clear_plogin() {
  if (_internal_has_plogin()) {
    if (GetArena() == nullptr) {
      delete Data_.plogin_;
    }
    clear_has_Data();
  }
}
inline ::pb::PlayerLogin* PlayerReqMsg::release_plogin() {
  // @@protoc_insertion_point(field_release:pb.PlayerReqMsg.PLogin)
  if (_internal_has_plogin()) {
    clear_has_Data();
      ::pb::PlayerLogin* temp = Data_.plogin_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Data_.plogin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::PlayerLogin& PlayerReqMsg::_internal_plogin() const {
  return _internal_has_plogin()
      ? *Data_.plogin_
      : reinterpret_cast< ::pb::PlayerLogin&>(::pb::_PlayerLogin_default_instance_);
}
inline const ::pb::PlayerLogin& PlayerReqMsg::plogin() const {
  // @@protoc_insertion_point(field_get:pb.PlayerReqMsg.PLogin)
  return _internal_plogin();
}
inline ::pb::PlayerLogin* PlayerReqMsg::unsafe_arena_release_plogin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.PlayerReqMsg.PLogin)
  if (_internal_has_plogin()) {
    clear_has_Data();
    ::pb::PlayerLogin* temp = Data_.plogin_;
    Data_.plogin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerReqMsg::unsafe_arena_set_allocated_plogin(::pb::PlayerLogin* plogin) {
  clear_Data();
  if (plogin) {
    set_has_plogin();
    Data_.plogin_ = plogin;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.PlayerReqMsg.PLogin)
}
inline ::pb::PlayerLogin* PlayerReqMsg::_internal_mutable_plogin() {
  if (!_internal_has_plogin()) {
    clear_Data();
    set_has_plogin();
    Data_.plogin_ = CreateMaybeMessage< ::pb::PlayerLogin >(GetArena());
  }
  return Data_.plogin_;
}
inline ::pb::PlayerLogin* PlayerReqMsg::mutable_plogin() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerReqMsg.PLogin)
  return _internal_mutable_plogin();
}

// .pb.PlayerJoin PJoin = 3;
inline bool PlayerReqMsg::_internal_has_pjoin() const {
  return Data_case() == kPJoin;
}
inline bool PlayerReqMsg::has_pjoin() const {
  return _internal_has_pjoin();
}
inline void PlayerReqMsg::set_has_pjoin() {
  _oneof_case_[0] = kPJoin;
}
inline void PlayerReqMsg::clear_pjoin() {
  if (_internal_has_pjoin()) {
    if (GetArena() == nullptr) {
      delete Data_.pjoin_;
    }
    clear_has_Data();
  }
}
inline ::pb::PlayerJoin* PlayerReqMsg::release_pjoin() {
  // @@protoc_insertion_point(field_release:pb.PlayerReqMsg.PJoin)
  if (_internal_has_pjoin()) {
    clear_has_Data();
      ::pb::PlayerJoin* temp = Data_.pjoin_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Data_.pjoin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::PlayerJoin& PlayerReqMsg::_internal_pjoin() const {
  return _internal_has_pjoin()
      ? *Data_.pjoin_
      : reinterpret_cast< ::pb::PlayerJoin&>(::pb::_PlayerJoin_default_instance_);
}
inline const ::pb::PlayerJoin& PlayerReqMsg::pjoin() const {
  // @@protoc_insertion_point(field_get:pb.PlayerReqMsg.PJoin)
  return _internal_pjoin();
}
inline ::pb::PlayerJoin* PlayerReqMsg::unsafe_arena_release_pjoin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.PlayerReqMsg.PJoin)
  if (_internal_has_pjoin()) {
    clear_has_Data();
    ::pb::PlayerJoin* temp = Data_.pjoin_;
    Data_.pjoin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerReqMsg::unsafe_arena_set_allocated_pjoin(::pb::PlayerJoin* pjoin) {
  clear_Data();
  if (pjoin) {
    set_has_pjoin();
    Data_.pjoin_ = pjoin;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.PlayerReqMsg.PJoin)
}
inline ::pb::PlayerJoin* PlayerReqMsg::_internal_mutable_pjoin() {
  if (!_internal_has_pjoin()) {
    clear_Data();
    set_has_pjoin();
    Data_.pjoin_ = CreateMaybeMessage< ::pb::PlayerJoin >(GetArena());
  }
  return Data_.pjoin_;
}
inline ::pb::PlayerJoin* PlayerReqMsg::mutable_pjoin() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerReqMsg.PJoin)
  return _internal_mutable_pjoin();
}

// .pb.PlayerLeave PLeave = 4;
inline bool PlayerReqMsg::_internal_has_pleave() const {
  return Data_case() == kPLeave;
}
inline bool PlayerReqMsg::has_pleave() const {
  return _internal_has_pleave();
}
inline void PlayerReqMsg::set_has_pleave() {
  _oneof_case_[0] = kPLeave;
}
inline void PlayerReqMsg::clear_pleave() {
  if (_internal_has_pleave()) {
    if (GetArena() == nullptr) {
      delete Data_.pleave_;
    }
    clear_has_Data();
  }
}
inline ::pb::PlayerLeave* PlayerReqMsg::release_pleave() {
  // @@protoc_insertion_point(field_release:pb.PlayerReqMsg.PLeave)
  if (_internal_has_pleave()) {
    clear_has_Data();
      ::pb::PlayerLeave* temp = Data_.pleave_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Data_.pleave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::PlayerLeave& PlayerReqMsg::_internal_pleave() const {
  return _internal_has_pleave()
      ? *Data_.pleave_
      : reinterpret_cast< ::pb::PlayerLeave&>(::pb::_PlayerLeave_default_instance_);
}
inline const ::pb::PlayerLeave& PlayerReqMsg::pleave() const {
  // @@protoc_insertion_point(field_get:pb.PlayerReqMsg.PLeave)
  return _internal_pleave();
}
inline ::pb::PlayerLeave* PlayerReqMsg::unsafe_arena_release_pleave() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.PlayerReqMsg.PLeave)
  if (_internal_has_pleave()) {
    clear_has_Data();
    ::pb::PlayerLeave* temp = Data_.pleave_;
    Data_.pleave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerReqMsg::unsafe_arena_set_allocated_pleave(::pb::PlayerLeave* pleave) {
  clear_Data();
  if (pleave) {
    set_has_pleave();
    Data_.pleave_ = pleave;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.PlayerReqMsg.PLeave)
}
inline ::pb::PlayerLeave* PlayerReqMsg::_internal_mutable_pleave() {
  if (!_internal_has_pleave()) {
    clear_Data();
    set_has_pleave();
    Data_.pleave_ = CreateMaybeMessage< ::pb::PlayerLeave >(GetArena());
  }
  return Data_.pleave_;
}
inline ::pb::PlayerLeave* PlayerReqMsg::mutable_pleave() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerReqMsg.PLeave)
  return _internal_mutable_pleave();
}

// .pb.PlayerOther POther = 5;
inline bool PlayerReqMsg::_internal_has_pother() const {
  return Data_case() == kPOther;
}
inline bool PlayerReqMsg::has_pother() const {
  return _internal_has_pother();
}
inline void PlayerReqMsg::set_has_pother() {
  _oneof_case_[0] = kPOther;
}
inline void PlayerReqMsg::clear_pother() {
  if (_internal_has_pother()) {
    if (GetArena() == nullptr) {
      delete Data_.pother_;
    }
    clear_has_Data();
  }
}
inline ::pb::PlayerOther* PlayerReqMsg::release_pother() {
  // @@protoc_insertion_point(field_release:pb.PlayerReqMsg.POther)
  if (_internal_has_pother()) {
    clear_has_Data();
      ::pb::PlayerOther* temp = Data_.pother_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Data_.pother_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::PlayerOther& PlayerReqMsg::_internal_pother() const {
  return _internal_has_pother()
      ? *Data_.pother_
      : reinterpret_cast< ::pb::PlayerOther&>(::pb::_PlayerOther_default_instance_);
}
inline const ::pb::PlayerOther& PlayerReqMsg::pother() const {
  // @@protoc_insertion_point(field_get:pb.PlayerReqMsg.POther)
  return _internal_pother();
}
inline ::pb::PlayerOther* PlayerReqMsg::unsafe_arena_release_pother() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.PlayerReqMsg.POther)
  if (_internal_has_pother()) {
    clear_has_Data();
    ::pb::PlayerOther* temp = Data_.pother_;
    Data_.pother_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerReqMsg::unsafe_arena_set_allocated_pother(::pb::PlayerOther* pother) {
  clear_Data();
  if (pother) {
    set_has_pother();
    Data_.pother_ = pother;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.PlayerReqMsg.POther)
}
inline ::pb::PlayerOther* PlayerReqMsg::_internal_mutable_pother() {
  if (!_internal_has_pother()) {
    clear_Data();
    set_has_pother();
    Data_.pother_ = CreateMaybeMessage< ::pb::PlayerOther >(GetArena());
  }
  return Data_.pother_;
}
inline ::pb::PlayerOther* PlayerReqMsg::mutable_pother() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerReqMsg.POther)
  return _internal_mutable_pother();
}

inline bool PlayerReqMsg::has_Data() const {
  return Data_case() != DATA_NOT_SET;
}
inline void PlayerReqMsg::clear_has_Data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline PlayerReqMsg::DataCase PlayerReqMsg::Data_case() const {
  return PlayerReqMsg::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// PlayerResMsg

// string PID = 1;
inline void PlayerResMsg::clear_pid() {
  pid_.ClearToEmpty();
}
inline const std::string& PlayerResMsg::pid() const {
  // @@protoc_insertion_point(field_get:pb.PlayerResMsg.PID)
  return _internal_pid();
}
inline void PlayerResMsg::set_pid(const std::string& value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:pb.PlayerResMsg.PID)
}
inline std::string* PlayerResMsg::mutable_pid() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerResMsg.PID)
  return _internal_mutable_pid();
}
inline const std::string& PlayerResMsg::_internal_pid() const {
  return pid_.Get();
}
inline void PlayerResMsg::_internal_set_pid(const std::string& value) {
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PlayerResMsg::set_pid(std::string&& value) {
  
  pid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.PlayerResMsg.PID)
}
inline void PlayerResMsg::set_pid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.PlayerResMsg.PID)
}
inline void PlayerResMsg::set_pid(const char* value,
    size_t size) {
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.PlayerResMsg.PID)
}
inline std::string* PlayerResMsg::_internal_mutable_pid() {
  
  return pid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PlayerResMsg::release_pid() {
  // @@protoc_insertion_point(field_release:pb.PlayerResMsg.PID)
  return pid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PlayerResMsg::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  pid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.PlayerResMsg.PID)
}

// .pb.PlayerState PStatus = 2;
inline bool PlayerResMsg::_internal_has_pstatus() const {
  return Data_case() == kPStatus;
}
inline bool PlayerResMsg::has_pstatus() const {
  return _internal_has_pstatus();
}
inline void PlayerResMsg::set_has_pstatus() {
  _oneof_case_[0] = kPStatus;
}
inline void PlayerResMsg::clear_pstatus() {
  if (_internal_has_pstatus()) {
    if (GetArena() == nullptr) {
      delete Data_.pstatus_;
    }
    clear_has_Data();
  }
}
inline ::pb::PlayerState* PlayerResMsg::release_pstatus() {
  // @@protoc_insertion_point(field_release:pb.PlayerResMsg.PStatus)
  if (_internal_has_pstatus()) {
    clear_has_Data();
      ::pb::PlayerState* temp = Data_.pstatus_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Data_.pstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::PlayerState& PlayerResMsg::_internal_pstatus() const {
  return _internal_has_pstatus()
      ? *Data_.pstatus_
      : reinterpret_cast< ::pb::PlayerState&>(::pb::_PlayerState_default_instance_);
}
inline const ::pb::PlayerState& PlayerResMsg::pstatus() const {
  // @@protoc_insertion_point(field_get:pb.PlayerResMsg.PStatus)
  return _internal_pstatus();
}
inline ::pb::PlayerState* PlayerResMsg::unsafe_arena_release_pstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.PlayerResMsg.PStatus)
  if (_internal_has_pstatus()) {
    clear_has_Data();
    ::pb::PlayerState* temp = Data_.pstatus_;
    Data_.pstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerResMsg::unsafe_arena_set_allocated_pstatus(::pb::PlayerState* pstatus) {
  clear_Data();
  if (pstatus) {
    set_has_pstatus();
    Data_.pstatus_ = pstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.PlayerResMsg.PStatus)
}
inline ::pb::PlayerState* PlayerResMsg::_internal_mutable_pstatus() {
  if (!_internal_has_pstatus()) {
    clear_Data();
    set_has_pstatus();
    Data_.pstatus_ = CreateMaybeMessage< ::pb::PlayerState >(GetArena());
  }
  return Data_.pstatus_;
}
inline ::pb::PlayerState* PlayerResMsg::mutable_pstatus() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerResMsg.PStatus)
  return _internal_mutable_pstatus();
}

// .pb.PlayerInfo PInfo = 3;
inline bool PlayerResMsg::_internal_has_pinfo() const {
  return Data_case() == kPInfo;
}
inline bool PlayerResMsg::has_pinfo() const {
  return _internal_has_pinfo();
}
inline void PlayerResMsg::set_has_pinfo() {
  _oneof_case_[0] = kPInfo;
}
inline void PlayerResMsg::clear_pinfo() {
  if (_internal_has_pinfo()) {
    if (GetArena() == nullptr) {
      delete Data_.pinfo_;
    }
    clear_has_Data();
  }
}
inline ::pb::PlayerInfo* PlayerResMsg::release_pinfo() {
  // @@protoc_insertion_point(field_release:pb.PlayerResMsg.PInfo)
  if (_internal_has_pinfo()) {
    clear_has_Data();
      ::pb::PlayerInfo* temp = Data_.pinfo_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Data_.pinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::PlayerInfo& PlayerResMsg::_internal_pinfo() const {
  return _internal_has_pinfo()
      ? *Data_.pinfo_
      : reinterpret_cast< ::pb::PlayerInfo&>(::pb::_PlayerInfo_default_instance_);
}
inline const ::pb::PlayerInfo& PlayerResMsg::pinfo() const {
  // @@protoc_insertion_point(field_get:pb.PlayerResMsg.PInfo)
  return _internal_pinfo();
}
inline ::pb::PlayerInfo* PlayerResMsg::unsafe_arena_release_pinfo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.PlayerResMsg.PInfo)
  if (_internal_has_pinfo()) {
    clear_has_Data();
    ::pb::PlayerInfo* temp = Data_.pinfo_;
    Data_.pinfo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerResMsg::unsafe_arena_set_allocated_pinfo(::pb::PlayerInfo* pinfo) {
  clear_Data();
  if (pinfo) {
    set_has_pinfo();
    Data_.pinfo_ = pinfo;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.PlayerResMsg.PInfo)
}
inline ::pb::PlayerInfo* PlayerResMsg::_internal_mutable_pinfo() {
  if (!_internal_has_pinfo()) {
    clear_Data();
    set_has_pinfo();
    Data_.pinfo_ = CreateMaybeMessage< ::pb::PlayerInfo >(GetArena());
  }
  return Data_.pinfo_;
}
inline ::pb::PlayerInfo* PlayerResMsg::mutable_pinfo() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerResMsg.PInfo)
  return _internal_mutable_pinfo();
}

// .pb.PlayerList PList = 4;
inline bool PlayerResMsg::_internal_has_plist() const {
  return Data_case() == kPList;
}
inline bool PlayerResMsg::has_plist() const {
  return _internal_has_plist();
}
inline void PlayerResMsg::set_has_plist() {
  _oneof_case_[0] = kPList;
}
inline void PlayerResMsg::clear_plist() {
  if (_internal_has_plist()) {
    if (GetArena() == nullptr) {
      delete Data_.plist_;
    }
    clear_has_Data();
  }
}
inline ::pb::PlayerList* PlayerResMsg::release_plist() {
  // @@protoc_insertion_point(field_release:pb.PlayerResMsg.PList)
  if (_internal_has_plist()) {
    clear_has_Data();
      ::pb::PlayerList* temp = Data_.plist_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Data_.plist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::PlayerList& PlayerResMsg::_internal_plist() const {
  return _internal_has_plist()
      ? *Data_.plist_
      : reinterpret_cast< ::pb::PlayerList&>(::pb::_PlayerList_default_instance_);
}
inline const ::pb::PlayerList& PlayerResMsg::plist() const {
  // @@protoc_insertion_point(field_get:pb.PlayerResMsg.PList)
  return _internal_plist();
}
inline ::pb::PlayerList* PlayerResMsg::unsafe_arena_release_plist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.PlayerResMsg.PList)
  if (_internal_has_plist()) {
    clear_has_Data();
    ::pb::PlayerList* temp = Data_.plist_;
    Data_.plist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerResMsg::unsafe_arena_set_allocated_plist(::pb::PlayerList* plist) {
  clear_Data();
  if (plist) {
    set_has_plist();
    Data_.plist_ = plist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.PlayerResMsg.PList)
}
inline ::pb::PlayerList* PlayerResMsg::_internal_mutable_plist() {
  if (!_internal_has_plist()) {
    clear_Data();
    set_has_plist();
    Data_.plist_ = CreateMaybeMessage< ::pb::PlayerList >(GetArena());
  }
  return Data_.plist_;
}
inline ::pb::PlayerList* PlayerResMsg::mutable_plist() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerResMsg.PList)
  return _internal_mutable_plist();
}

// .pb.PlayerJoin PJoin = 5;
inline bool PlayerResMsg::_internal_has_pjoin() const {
  return Data_case() == kPJoin;
}
inline bool PlayerResMsg::has_pjoin() const {
  return _internal_has_pjoin();
}
inline void PlayerResMsg::set_has_pjoin() {
  _oneof_case_[0] = kPJoin;
}
inline void PlayerResMsg::clear_pjoin() {
  if (_internal_has_pjoin()) {
    if (GetArena() == nullptr) {
      delete Data_.pjoin_;
    }
    clear_has_Data();
  }
}
inline ::pb::PlayerJoin* PlayerResMsg::release_pjoin() {
  // @@protoc_insertion_point(field_release:pb.PlayerResMsg.PJoin)
  if (_internal_has_pjoin()) {
    clear_has_Data();
      ::pb::PlayerJoin* temp = Data_.pjoin_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Data_.pjoin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::PlayerJoin& PlayerResMsg::_internal_pjoin() const {
  return _internal_has_pjoin()
      ? *Data_.pjoin_
      : reinterpret_cast< ::pb::PlayerJoin&>(::pb::_PlayerJoin_default_instance_);
}
inline const ::pb::PlayerJoin& PlayerResMsg::pjoin() const {
  // @@protoc_insertion_point(field_get:pb.PlayerResMsg.PJoin)
  return _internal_pjoin();
}
inline ::pb::PlayerJoin* PlayerResMsg::unsafe_arena_release_pjoin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.PlayerResMsg.PJoin)
  if (_internal_has_pjoin()) {
    clear_has_Data();
    ::pb::PlayerJoin* temp = Data_.pjoin_;
    Data_.pjoin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerResMsg::unsafe_arena_set_allocated_pjoin(::pb::PlayerJoin* pjoin) {
  clear_Data();
  if (pjoin) {
    set_has_pjoin();
    Data_.pjoin_ = pjoin;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.PlayerResMsg.PJoin)
}
inline ::pb::PlayerJoin* PlayerResMsg::_internal_mutable_pjoin() {
  if (!_internal_has_pjoin()) {
    clear_Data();
    set_has_pjoin();
    Data_.pjoin_ = CreateMaybeMessage< ::pb::PlayerJoin >(GetArena());
  }
  return Data_.pjoin_;
}
inline ::pb::PlayerJoin* PlayerResMsg::mutable_pjoin() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerResMsg.PJoin)
  return _internal_mutable_pjoin();
}

// .pb.PlayerLeave PLeave = 6;
inline bool PlayerResMsg::_internal_has_pleave() const {
  return Data_case() == kPLeave;
}
inline bool PlayerResMsg::has_pleave() const {
  return _internal_has_pleave();
}
inline void PlayerResMsg::set_has_pleave() {
  _oneof_case_[0] = kPLeave;
}
inline void PlayerResMsg::clear_pleave() {
  if (_internal_has_pleave()) {
    if (GetArena() == nullptr) {
      delete Data_.pleave_;
    }
    clear_has_Data();
  }
}
inline ::pb::PlayerLeave* PlayerResMsg::release_pleave() {
  // @@protoc_insertion_point(field_release:pb.PlayerResMsg.PLeave)
  if (_internal_has_pleave()) {
    clear_has_Data();
      ::pb::PlayerLeave* temp = Data_.pleave_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Data_.pleave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::PlayerLeave& PlayerResMsg::_internal_pleave() const {
  return _internal_has_pleave()
      ? *Data_.pleave_
      : reinterpret_cast< ::pb::PlayerLeave&>(::pb::_PlayerLeave_default_instance_);
}
inline const ::pb::PlayerLeave& PlayerResMsg::pleave() const {
  // @@protoc_insertion_point(field_get:pb.PlayerResMsg.PLeave)
  return _internal_pleave();
}
inline ::pb::PlayerLeave* PlayerResMsg::unsafe_arena_release_pleave() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.PlayerResMsg.PLeave)
  if (_internal_has_pleave()) {
    clear_has_Data();
    ::pb::PlayerLeave* temp = Data_.pleave_;
    Data_.pleave_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerResMsg::unsafe_arena_set_allocated_pleave(::pb::PlayerLeave* pleave) {
  clear_Data();
  if (pleave) {
    set_has_pleave();
    Data_.pleave_ = pleave;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.PlayerResMsg.PLeave)
}
inline ::pb::PlayerLeave* PlayerResMsg::_internal_mutable_pleave() {
  if (!_internal_has_pleave()) {
    clear_Data();
    set_has_pleave();
    Data_.pleave_ = CreateMaybeMessage< ::pb::PlayerLeave >(GetArena());
  }
  return Data_.pleave_;
}
inline ::pb::PlayerLeave* PlayerResMsg::mutable_pleave() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerResMsg.PLeave)
  return _internal_mutable_pleave();
}

// .pb.PLeaveList PLList = 7;
inline bool PlayerResMsg::_internal_has_pllist() const {
  return Data_case() == kPLList;
}
inline bool PlayerResMsg::has_pllist() const {
  return _internal_has_pllist();
}
inline void PlayerResMsg::set_has_pllist() {
  _oneof_case_[0] = kPLList;
}
inline void PlayerResMsg::clear_pllist() {
  if (_internal_has_pllist()) {
    if (GetArena() == nullptr) {
      delete Data_.pllist_;
    }
    clear_has_Data();
  }
}
inline ::pb::PLeaveList* PlayerResMsg::release_pllist() {
  // @@protoc_insertion_point(field_release:pb.PlayerResMsg.PLList)
  if (_internal_has_pllist()) {
    clear_has_Data();
      ::pb::PLeaveList* temp = Data_.pllist_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Data_.pllist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::PLeaveList& PlayerResMsg::_internal_pllist() const {
  return _internal_has_pllist()
      ? *Data_.pllist_
      : reinterpret_cast< ::pb::PLeaveList&>(::pb::_PLeaveList_default_instance_);
}
inline const ::pb::PLeaveList& PlayerResMsg::pllist() const {
  // @@protoc_insertion_point(field_get:pb.PlayerResMsg.PLList)
  return _internal_pllist();
}
inline ::pb::PLeaveList* PlayerResMsg::unsafe_arena_release_pllist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.PlayerResMsg.PLList)
  if (_internal_has_pllist()) {
    clear_has_Data();
    ::pb::PLeaveList* temp = Data_.pllist_;
    Data_.pllist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PlayerResMsg::unsafe_arena_set_allocated_pllist(::pb::PLeaveList* pllist) {
  clear_Data();
  if (pllist) {
    set_has_pllist();
    Data_.pllist_ = pllist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.PlayerResMsg.PLList)
}
inline ::pb::PLeaveList* PlayerResMsg::_internal_mutable_pllist() {
  if (!_internal_has_pllist()) {
    clear_Data();
    set_has_pllist();
    Data_.pllist_ = CreateMaybeMessage< ::pb::PLeaveList >(GetArena());
  }
  return Data_.pllist_;
}
inline ::pb::PLeaveList* PlayerResMsg::mutable_pllist() {
  // @@protoc_insertion_point(field_mutable:pb.PlayerResMsg.PLList)
  return _internal_mutable_pllist();
}

inline bool PlayerResMsg::has_Data() const {
  return Data_case() != DATA_NOT_SET;
}
inline void PlayerResMsg::clear_has_Data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline PlayerResMsg::DataCase PlayerResMsg::Data_case() const {
  return PlayerResMsg::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SysMsg

// string PID = 1;
inline void SysMsg::clear_pid() {
  pid_.ClearToEmpty();
}
inline const std::string& SysMsg::pid() const {
  // @@protoc_insertion_point(field_get:pb.SysMsg.PID)
  return _internal_pid();
}
inline void SysMsg::set_pid(const std::string& value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:pb.SysMsg.PID)
}
inline std::string* SysMsg::mutable_pid() {
  // @@protoc_insertion_point(field_mutable:pb.SysMsg.PID)
  return _internal_mutable_pid();
}
inline const std::string& SysMsg::_internal_pid() const {
  return pid_.Get();
}
inline void SysMsg::_internal_set_pid(const std::string& value) {
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void SysMsg::set_pid(std::string&& value) {
  
  pid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.SysMsg.PID)
}
inline void SysMsg::set_pid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.SysMsg.PID)
}
inline void SysMsg::set_pid(const char* value,
    size_t size) {
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.SysMsg.PID)
}
inline std::string* SysMsg::_internal_mutable_pid() {
  
  return pid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SysMsg::release_pid() {
  // @@protoc_insertion_point(field_release:pb.SysMsg.PID)
  return pid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SysMsg::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  pid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.SysMsg.PID)
}

// string Content = 2;
inline void SysMsg::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& SysMsg::content() const {
  // @@protoc_insertion_point(field_get:pb.SysMsg.Content)
  return _internal_content();
}
inline void SysMsg::set_content(const std::string& value) {
  _internal_set_content(value);
  // @@protoc_insertion_point(field_set:pb.SysMsg.Content)
}
inline std::string* SysMsg::mutable_content() {
  // @@protoc_insertion_point(field_mutable:pb.SysMsg.Content)
  return _internal_mutable_content();
}
inline const std::string& SysMsg::_internal_content() const {
  return content_.Get();
}
inline void SysMsg::_internal_set_content(const std::string& value) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void SysMsg::set_content(std::string&& value) {
  
  content_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.SysMsg.Content)
}
inline void SysMsg::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.SysMsg.Content)
}
inline void SysMsg::set_content(const char* value,
    size_t size) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.SysMsg.Content)
}
inline std::string* SysMsg::_internal_mutable_content() {
  
  return content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* SysMsg::release_content() {
  // @@protoc_insertion_point(field_release:pb.SysMsg.Content)
  return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void SysMsg::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.SysMsg.Content)
}

// -------------------------------------------------------------------

// TalkMsg

// string PID = 1;
inline void TalkMsg::clear_pid() {
  pid_.ClearToEmpty();
}
inline const std::string& TalkMsg::pid() const {
  // @@protoc_insertion_point(field_get:pb.TalkMsg.PID)
  return _internal_pid();
}
inline void TalkMsg::set_pid(const std::string& value) {
  _internal_set_pid(value);
  // @@protoc_insertion_point(field_set:pb.TalkMsg.PID)
}
inline std::string* TalkMsg::mutable_pid() {
  // @@protoc_insertion_point(field_mutable:pb.TalkMsg.PID)
  return _internal_mutable_pid();
}
inline const std::string& TalkMsg::_internal_pid() const {
  return pid_.Get();
}
inline void TalkMsg::_internal_set_pid(const std::string& value) {
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TalkMsg::set_pid(std::string&& value) {
  
  pid_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.TalkMsg.PID)
}
inline void TalkMsg::set_pid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.TalkMsg.PID)
}
inline void TalkMsg::set_pid(const char* value,
    size_t size) {
  
  pid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.TalkMsg.PID)
}
inline std::string* TalkMsg::_internal_mutable_pid() {
  
  return pid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TalkMsg::release_pid() {
  // @@protoc_insertion_point(field_release:pb.TalkMsg.PID)
  return pid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TalkMsg::set_allocated_pid(std::string* pid) {
  if (pid != nullptr) {
    
  } else {
    
  }
  pid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.TalkMsg.PID)
}

// string Content = 2;
inline void TalkMsg::clear_content() {
  content_.ClearToEmpty();
}
inline const std::string& TalkMsg::content() const {
  // @@protoc_insertion_point(field_get:pb.TalkMsg.Content)
  return _internal_content();
}
inline void TalkMsg::set_content(const std::string& value) {
  _internal_set_content(value);
  // @@protoc_insertion_point(field_set:pb.TalkMsg.Content)
}
inline std::string* TalkMsg::mutable_content() {
  // @@protoc_insertion_point(field_mutable:pb.TalkMsg.Content)
  return _internal_mutable_content();
}
inline const std::string& TalkMsg::_internal_content() const {
  return content_.Get();
}
inline void TalkMsg::_internal_set_content(const std::string& value) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void TalkMsg::set_content(std::string&& value) {
  
  content_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.TalkMsg.Content)
}
inline void TalkMsg::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.TalkMsg.Content)
}
inline void TalkMsg::set_content(const char* value,
    size_t size) {
  
  content_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.TalkMsg.Content)
}
inline std::string* TalkMsg::_internal_mutable_content() {
  
  return content_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* TalkMsg::release_content() {
  // @@protoc_insertion_point(field_release:pb.TalkMsg.Content)
  return content_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TalkMsg::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  content_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), content,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.TalkMsg.Content)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_msg_2eproto
