// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: br.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_br_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_br_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_br_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_br_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_br_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_br_2eproto_metadata_getter(int index);
namespace pb {
class LotteryInfo;
struct LotteryInfoDefaultTypeInternal;
extern LotteryInfoDefaultTypeInternal _LotteryInfo_default_instance_;
class LotteryLatest;
struct LotteryLatestDefaultTypeInternal;
extern LotteryLatestDefaultTypeInternal _LotteryLatest_default_instance_;
class LotteryList;
struct LotteryListDefaultTypeInternal;
extern LotteryListDefaultTypeInternal _LotteryList_default_instance_;
class LotteryNext;
struct LotteryNextDefaultTypeInternal;
extern LotteryNextDefaultTypeInternal _LotteryNext_default_instance_;
class LotteryRequest;
struct LotteryRequestDefaultTypeInternal;
extern LotteryRequestDefaultTypeInternal _LotteryRequest_default_instance_;
class LotteryResponse;
struct LotteryResponseDefaultTypeInternal;
extern LotteryResponseDefaultTypeInternal _LotteryResponse_default_instance_;
class LotteryServer;
struct LotteryServerDefaultTypeInternal;
extern LotteryServerDefaultTypeInternal _LotteryServer_default_instance_;
class LotteryState;
struct LotteryStateDefaultTypeInternal;
extern LotteryStateDefaultTypeInternal _LotteryState_default_instance_;
}  // namespace pb
PROTOBUF_NAMESPACE_OPEN
template<> ::pb::LotteryInfo* Arena::CreateMaybeMessage<::pb::LotteryInfo>(Arena*);
template<> ::pb::LotteryLatest* Arena::CreateMaybeMessage<::pb::LotteryLatest>(Arena*);
template<> ::pb::LotteryList* Arena::CreateMaybeMessage<::pb::LotteryList>(Arena*);
template<> ::pb::LotteryNext* Arena::CreateMaybeMessage<::pb::LotteryNext>(Arena*);
template<> ::pb::LotteryRequest* Arena::CreateMaybeMessage<::pb::LotteryRequest>(Arena*);
template<> ::pb::LotteryResponse* Arena::CreateMaybeMessage<::pb::LotteryResponse>(Arena*);
template<> ::pb::LotteryServer* Arena::CreateMaybeMessage<::pb::LotteryServer>(Arena*);
template<> ::pb::LotteryState* Arena::CreateMaybeMessage<::pb::LotteryState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pb {

// ===================================================================

class LotteryState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.LotteryState) */ {
 public:
  inline LotteryState() : LotteryState(nullptr) {}
  virtual ~LotteryState();
  explicit constexpr LotteryState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LotteryState(const LotteryState& from);
  LotteryState(LotteryState&& from) noexcept
    : LotteryState() {
    *this = ::std::move(from);
  }

  inline LotteryState& operator=(const LotteryState& from) {
    CopyFrom(from);
    return *this;
  }
  inline LotteryState& operator=(LotteryState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LotteryState& default_instance() {
    return *internal_default_instance();
  }
  static inline const LotteryState* internal_default_instance() {
    return reinterpret_cast<const LotteryState*>(
               &_LotteryState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LotteryState& a, LotteryState& b) {
    a.Swap(&b);
  }
  inline void Swap(LotteryState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LotteryState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LotteryState* New() const final {
    return CreateMaybeMessage<LotteryState>(nullptr);
  }

  LotteryState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LotteryState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LotteryState& from);
  void MergeFrom(const LotteryState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LotteryState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.LotteryState";
  }
  protected:
  explicit LotteryState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_br_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kCodeFieldNumber = 2,
  };
  // int32 Type = 1;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 Code = 2;
  void clear_code();
  ::PROTOBUF_NAMESPACE_ID::int32 code() const;
  void set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_code() const;
  void _internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.LotteryState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  ::PROTOBUF_NAMESPACE_ID::int32 code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_br_2eproto;
};
// -------------------------------------------------------------------

class LotteryServer PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.LotteryServer) */ {
 public:
  inline LotteryServer() : LotteryServer(nullptr) {}
  virtual ~LotteryServer();
  explicit constexpr LotteryServer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LotteryServer(const LotteryServer& from);
  LotteryServer(LotteryServer&& from) noexcept
    : LotteryServer() {
    *this = ::std::move(from);
  }

  inline LotteryServer& operator=(const LotteryServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline LotteryServer& operator=(LotteryServer&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LotteryServer& default_instance() {
    return *internal_default_instance();
  }
  static inline const LotteryServer* internal_default_instance() {
    return reinterpret_cast<const LotteryServer*>(
               &_LotteryServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LotteryServer& a, LotteryServer& b) {
    a.Swap(&b);
  }
  inline void Swap(LotteryServer* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LotteryServer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LotteryServer* New() const final {
    return CreateMaybeMessage<LotteryServer>(nullptr);
  }

  LotteryServer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LotteryServer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LotteryServer& from);
  void MergeFrom(const LotteryServer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LotteryServer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.LotteryServer";
  }
  protected:
  explicit LotteryServer(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_br_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerTimeFieldNumber = 1,
  };
  // string ServerTime = 1;
  void clear_servertime();
  const std::string& servertime() const;
  void set_servertime(const std::string& value);
  void set_servertime(std::string&& value);
  void set_servertime(const char* value);
  void set_servertime(const char* value, size_t size);
  std::string* mutable_servertime();
  std::string* release_servertime();
  void set_allocated_servertime(std::string* servertime);
  private:
  const std::string& _internal_servertime() const;
  void _internal_set_servertime(const std::string& value);
  std::string* _internal_mutable_servertime();
  public:

  // @@protoc_insertion_point(class_scope:pb.LotteryServer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr servertime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_br_2eproto;
};
// -------------------------------------------------------------------

class LotteryInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.LotteryInfo) */ {
 public:
  inline LotteryInfo() : LotteryInfo(nullptr) {}
  virtual ~LotteryInfo();
  explicit constexpr LotteryInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LotteryInfo(const LotteryInfo& from);
  LotteryInfo(LotteryInfo&& from) noexcept
    : LotteryInfo() {
    *this = ::std::move(from);
  }

  inline LotteryInfo& operator=(const LotteryInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LotteryInfo& operator=(LotteryInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LotteryInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const LotteryInfo* internal_default_instance() {
    return reinterpret_cast<const LotteryInfo*>(
               &_LotteryInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LotteryInfo& a, LotteryInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LotteryInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LotteryInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LotteryInfo* New() const final {
    return CreateMaybeMessage<LotteryInfo>(nullptr);
  }

  LotteryInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LotteryInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LotteryInfo& from);
  void MergeFrom(const LotteryInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LotteryInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.LotteryInfo";
  }
  protected:
  explicit LotteryInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_br_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeriodsFieldNumber = 1,
    kBeginTimeFieldNumber = 2,
    kOpenTimeFieldNumber = 3,
    kCollectTimeFieldNumber = 4,
    kOpenContentFieldNumber = 5,
  };
  // string Periods = 1;
  void clear_periods();
  const std::string& periods() const;
  void set_periods(const std::string& value);
  void set_periods(std::string&& value);
  void set_periods(const char* value);
  void set_periods(const char* value, size_t size);
  std::string* mutable_periods();
  std::string* release_periods();
  void set_allocated_periods(std::string* periods);
  private:
  const std::string& _internal_periods() const;
  void _internal_set_periods(const std::string& value);
  std::string* _internal_mutable_periods();
  public:

  // string BeginTime = 2;
  void clear_begintime();
  const std::string& begintime() const;
  void set_begintime(const std::string& value);
  void set_begintime(std::string&& value);
  void set_begintime(const char* value);
  void set_begintime(const char* value, size_t size);
  std::string* mutable_begintime();
  std::string* release_begintime();
  void set_allocated_begintime(std::string* begintime);
  private:
  const std::string& _internal_begintime() const;
  void _internal_set_begintime(const std::string& value);
  std::string* _internal_mutable_begintime();
  public:

  // string OpenTime = 3;
  void clear_opentime();
  const std::string& opentime() const;
  void set_opentime(const std::string& value);
  void set_opentime(std::string&& value);
  void set_opentime(const char* value);
  void set_opentime(const char* value, size_t size);
  std::string* mutable_opentime();
  std::string* release_opentime();
  void set_allocated_opentime(std::string* opentime);
  private:
  const std::string& _internal_opentime() const;
  void _internal_set_opentime(const std::string& value);
  std::string* _internal_mutable_opentime();
  public:

  // string CollectTime = 4;
  void clear_collecttime();
  const std::string& collecttime() const;
  void set_collecttime(const std::string& value);
  void set_collecttime(std::string&& value);
  void set_collecttime(const char* value);
  void set_collecttime(const char* value, size_t size);
  std::string* mutable_collecttime();
  std::string* release_collecttime();
  void set_allocated_collecttime(std::string* collecttime);
  private:
  const std::string& _internal_collecttime() const;
  void _internal_set_collecttime(const std::string& value);
  std::string* _internal_mutable_collecttime();
  public:

  // string OpenContent = 5;
  void clear_opencontent();
  const std::string& opencontent() const;
  void set_opencontent(const std::string& value);
  void set_opencontent(std::string&& value);
  void set_opencontent(const char* value);
  void set_opencontent(const char* value, size_t size);
  std::string* mutable_opencontent();
  std::string* release_opencontent();
  void set_allocated_opencontent(std::string* opencontent);
  private:
  const std::string& _internal_opencontent() const;
  void _internal_set_opencontent(const std::string& value);
  std::string* _internal_mutable_opencontent();
  public:

  // @@protoc_insertion_point(class_scope:pb.LotteryInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr periods_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr begintime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr opentime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr collecttime_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr opencontent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_br_2eproto;
};
// -------------------------------------------------------------------

class LotteryList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.LotteryList) */ {
 public:
  inline LotteryList() : LotteryList(nullptr) {}
  virtual ~LotteryList();
  explicit constexpr LotteryList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LotteryList(const LotteryList& from);
  LotteryList(LotteryList&& from) noexcept
    : LotteryList() {
    *this = ::std::move(from);
  }

  inline LotteryList& operator=(const LotteryList& from) {
    CopyFrom(from);
    return *this;
  }
  inline LotteryList& operator=(LotteryList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LotteryList& default_instance() {
    return *internal_default_instance();
  }
  static inline const LotteryList* internal_default_instance() {
    return reinterpret_cast<const LotteryList*>(
               &_LotteryList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LotteryList& a, LotteryList& b) {
    a.Swap(&b);
  }
  inline void Swap(LotteryList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LotteryList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LotteryList* New() const final {
    return CreateMaybeMessage<LotteryList>(nullptr);
  }

  LotteryList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LotteryList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LotteryList& from);
  void MergeFrom(const LotteryList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LotteryList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.LotteryList";
  }
  protected:
  explicit LotteryList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_br_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLotterysFieldNumber = 1,
  };
  // repeated .pb.LotteryInfo Lotterys = 1;
  int lotterys_size() const;
  private:
  int _internal_lotterys_size() const;
  public:
  void clear_lotterys();
  ::pb::LotteryInfo* mutable_lotterys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::LotteryInfo >*
      mutable_lotterys();
  private:
  const ::pb::LotteryInfo& _internal_lotterys(int index) const;
  ::pb::LotteryInfo* _internal_add_lotterys();
  public:
  const ::pb::LotteryInfo& lotterys(int index) const;
  ::pb::LotteryInfo* add_lotterys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::LotteryInfo >&
      lotterys() const;

  // @@protoc_insertion_point(class_scope:pb.LotteryList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::LotteryInfo > lotterys_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_br_2eproto;
};
// -------------------------------------------------------------------

class LotteryNext PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.LotteryNext) */ {
 public:
  inline LotteryNext() : LotteryNext(nullptr) {}
  virtual ~LotteryNext();
  explicit constexpr LotteryNext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LotteryNext(const LotteryNext& from);
  LotteryNext(LotteryNext&& from) noexcept
    : LotteryNext() {
    *this = ::std::move(from);
  }

  inline LotteryNext& operator=(const LotteryNext& from) {
    CopyFrom(from);
    return *this;
  }
  inline LotteryNext& operator=(LotteryNext&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LotteryNext& default_instance() {
    return *internal_default_instance();
  }
  static inline const LotteryNext* internal_default_instance() {
    return reinterpret_cast<const LotteryNext*>(
               &_LotteryNext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LotteryNext& a, LotteryNext& b) {
    a.Swap(&b);
  }
  inline void Swap(LotteryNext* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LotteryNext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LotteryNext* New() const final {
    return CreateMaybeMessage<LotteryNext>(nullptr);
  }

  LotteryNext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LotteryNext>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LotteryNext& from);
  void MergeFrom(const LotteryNext& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LotteryNext* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.LotteryNext";
  }
  protected:
  explicit LotteryNext(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_br_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLotInfoFieldNumber = 1,
  };
  // .pb.LotteryInfo LotInfo = 1;
  bool has_lotinfo() const;
  private:
  bool _internal_has_lotinfo() const;
  public:
  void clear_lotinfo();
  const ::pb::LotteryInfo& lotinfo() const;
  ::pb::LotteryInfo* release_lotinfo();
  ::pb::LotteryInfo* mutable_lotinfo();
  void set_allocated_lotinfo(::pb::LotteryInfo* lotinfo);
  private:
  const ::pb::LotteryInfo& _internal_lotinfo() const;
  ::pb::LotteryInfo* _internal_mutable_lotinfo();
  public:
  void unsafe_arena_set_allocated_lotinfo(
      ::pb::LotteryInfo* lotinfo);
  ::pb::LotteryInfo* unsafe_arena_release_lotinfo();

  // @@protoc_insertion_point(class_scope:pb.LotteryNext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pb::LotteryInfo* lotinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_br_2eproto;
};
// -------------------------------------------------------------------

class LotteryLatest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.LotteryLatest) */ {
 public:
  inline LotteryLatest() : LotteryLatest(nullptr) {}
  virtual ~LotteryLatest();
  explicit constexpr LotteryLatest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LotteryLatest(const LotteryLatest& from);
  LotteryLatest(LotteryLatest&& from) noexcept
    : LotteryLatest() {
    *this = ::std::move(from);
  }

  inline LotteryLatest& operator=(const LotteryLatest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LotteryLatest& operator=(LotteryLatest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LotteryLatest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LotteryLatest* internal_default_instance() {
    return reinterpret_cast<const LotteryLatest*>(
               &_LotteryLatest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LotteryLatest& a, LotteryLatest& b) {
    a.Swap(&b);
  }
  inline void Swap(LotteryLatest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LotteryLatest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LotteryLatest* New() const final {
    return CreateMaybeMessage<LotteryLatest>(nullptr);
  }

  LotteryLatest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LotteryLatest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LotteryLatest& from);
  void MergeFrom(const LotteryLatest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LotteryLatest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.LotteryLatest";
  }
  protected:
  explicit LotteryLatest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_br_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLotInfoFieldNumber = 1,
  };
  // .pb.LotteryInfo LotInfo = 1;
  bool has_lotinfo() const;
  private:
  bool _internal_has_lotinfo() const;
  public:
  void clear_lotinfo();
  const ::pb::LotteryInfo& lotinfo() const;
  ::pb::LotteryInfo* release_lotinfo();
  ::pb::LotteryInfo* mutable_lotinfo();
  void set_allocated_lotinfo(::pb::LotteryInfo* lotinfo);
  private:
  const ::pb::LotteryInfo& _internal_lotinfo() const;
  ::pb::LotteryInfo* _internal_mutable_lotinfo();
  public:
  void unsafe_arena_set_allocated_lotinfo(
      ::pb::LotteryInfo* lotinfo);
  ::pb::LotteryInfo* unsafe_arena_release_lotinfo();

  // @@protoc_insertion_point(class_scope:pb.LotteryLatest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pb::LotteryInfo* lotinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_br_2eproto;
};
// -------------------------------------------------------------------

class LotteryRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.LotteryRequest) */ {
 public:
  inline LotteryRequest() : LotteryRequest(nullptr) {}
  virtual ~LotteryRequest();
  explicit constexpr LotteryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LotteryRequest(const LotteryRequest& from);
  LotteryRequest(LotteryRequest&& from) noexcept
    : LotteryRequest() {
    *this = ::std::move(from);
  }

  inline LotteryRequest& operator=(const LotteryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LotteryRequest& operator=(LotteryRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LotteryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LotteryRequest* internal_default_instance() {
    return reinterpret_cast<const LotteryRequest*>(
               &_LotteryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(LotteryRequest& a, LotteryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LotteryRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LotteryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LotteryRequest* New() const final {
    return CreateMaybeMessage<LotteryRequest>(nullptr);
  }

  LotteryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LotteryRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LotteryRequest& from);
  void MergeFrom(const LotteryRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LotteryRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.LotteryRequest";
  }
  protected:
  explicit LotteryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_br_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // int32 Type = 1;
  void clear_type();
  ::PROTOBUF_NAMESPACE_ID::int32 type() const;
  void set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_type() const;
  void _internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.LotteryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_br_2eproto;
};
// -------------------------------------------------------------------

class LotteryResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.LotteryResponse) */ {
 public:
  inline LotteryResponse() : LotteryResponse(nullptr) {}
  virtual ~LotteryResponse();
  explicit constexpr LotteryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LotteryResponse(const LotteryResponse& from);
  LotteryResponse(LotteryResponse&& from) noexcept
    : LotteryResponse() {
    *this = ::std::move(from);
  }

  inline LotteryResponse& operator=(const LotteryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LotteryResponse& operator=(LotteryResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LotteryResponse& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kLotStatus = 1,
    kLotServer = 2,
    kLotList = 3,
    kLotNext = 4,
    kLotLatest = 5,
    DATA_NOT_SET = 0,
  };

  static inline const LotteryResponse* internal_default_instance() {
    return reinterpret_cast<const LotteryResponse*>(
               &_LotteryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(LotteryResponse& a, LotteryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LotteryResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LotteryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LotteryResponse* New() const final {
    return CreateMaybeMessage<LotteryResponse>(nullptr);
  }

  LotteryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LotteryResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LotteryResponse& from);
  void MergeFrom(const LotteryResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LotteryResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.LotteryResponse";
  }
  protected:
  explicit LotteryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_br_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLotStatusFieldNumber = 1,
    kLotServerFieldNumber = 2,
    kLotListFieldNumber = 3,
    kLotNextFieldNumber = 4,
    kLotLatestFieldNumber = 5,
  };
  // .pb.LotteryState LotStatus = 1;
  bool has_lotstatus() const;
  private:
  bool _internal_has_lotstatus() const;
  public:
  void clear_lotstatus();
  const ::pb::LotteryState& lotstatus() const;
  ::pb::LotteryState* release_lotstatus();
  ::pb::LotteryState* mutable_lotstatus();
  void set_allocated_lotstatus(::pb::LotteryState* lotstatus);
  private:
  const ::pb::LotteryState& _internal_lotstatus() const;
  ::pb::LotteryState* _internal_mutable_lotstatus();
  public:
  void unsafe_arena_set_allocated_lotstatus(
      ::pb::LotteryState* lotstatus);
  ::pb::LotteryState* unsafe_arena_release_lotstatus();

  // .pb.LotteryServer LotServer = 2;
  bool has_lotserver() const;
  private:
  bool _internal_has_lotserver() const;
  public:
  void clear_lotserver();
  const ::pb::LotteryServer& lotserver() const;
  ::pb::LotteryServer* release_lotserver();
  ::pb::LotteryServer* mutable_lotserver();
  void set_allocated_lotserver(::pb::LotteryServer* lotserver);
  private:
  const ::pb::LotteryServer& _internal_lotserver() const;
  ::pb::LotteryServer* _internal_mutable_lotserver();
  public:
  void unsafe_arena_set_allocated_lotserver(
      ::pb::LotteryServer* lotserver);
  ::pb::LotteryServer* unsafe_arena_release_lotserver();

  // .pb.LotteryList LotList = 3;
  bool has_lotlist() const;
  private:
  bool _internal_has_lotlist() const;
  public:
  void clear_lotlist();
  const ::pb::LotteryList& lotlist() const;
  ::pb::LotteryList* release_lotlist();
  ::pb::LotteryList* mutable_lotlist();
  void set_allocated_lotlist(::pb::LotteryList* lotlist);
  private:
  const ::pb::LotteryList& _internal_lotlist() const;
  ::pb::LotteryList* _internal_mutable_lotlist();
  public:
  void unsafe_arena_set_allocated_lotlist(
      ::pb::LotteryList* lotlist);
  ::pb::LotteryList* unsafe_arena_release_lotlist();

  // .pb.LotteryNext LotNext = 4;
  bool has_lotnext() const;
  private:
  bool _internal_has_lotnext() const;
  public:
  void clear_lotnext();
  const ::pb::LotteryNext& lotnext() const;
  ::pb::LotteryNext* release_lotnext();
  ::pb::LotteryNext* mutable_lotnext();
  void set_allocated_lotnext(::pb::LotteryNext* lotnext);
  private:
  const ::pb::LotteryNext& _internal_lotnext() const;
  ::pb::LotteryNext* _internal_mutable_lotnext();
  public:
  void unsafe_arena_set_allocated_lotnext(
      ::pb::LotteryNext* lotnext);
  ::pb::LotteryNext* unsafe_arena_release_lotnext();

  // .pb.LotteryLatest LotLatest = 5;
  bool has_lotlatest() const;
  private:
  bool _internal_has_lotlatest() const;
  public:
  void clear_lotlatest();
  const ::pb::LotteryLatest& lotlatest() const;
  ::pb::LotteryLatest* release_lotlatest();
  ::pb::LotteryLatest* mutable_lotlatest();
  void set_allocated_lotlatest(::pb::LotteryLatest* lotlatest);
  private:
  const ::pb::LotteryLatest& _internal_lotlatest() const;
  ::pb::LotteryLatest* _internal_mutable_lotlatest();
  public:
  void unsafe_arena_set_allocated_lotlatest(
      ::pb::LotteryLatest* lotlatest);
  ::pb::LotteryLatest* unsafe_arena_release_lotlatest();

  void clear_Data();
  DataCase Data_case() const;
  // @@protoc_insertion_point(class_scope:pb.LotteryResponse)
 private:
  class _Internal;
  void set_has_lotstatus();
  void set_has_lotserver();
  void set_has_lotlist();
  void set_has_lotnext();
  void set_has_lotlatest();

  inline bool has_Data() const;
  inline void clear_has_Data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union DataUnion {
    constexpr DataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::pb::LotteryState* lotstatus_;
    ::pb::LotteryServer* lotserver_;
    ::pb::LotteryList* lotlist_;
    ::pb::LotteryNext* lotnext_;
    ::pb::LotteryLatest* lotlatest_;
  } Data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_br_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LotteryState

// int32 Type = 1;
inline void LotteryState::clear_type() {
  type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LotteryState::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LotteryState::type() const {
  // @@protoc_insertion_point(field_get:pb.LotteryState.Type)
  return _internal_type();
}
inline void LotteryState::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  type_ = value;
}
inline void LotteryState::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.LotteryState.Type)
}

// int32 Code = 2;
inline void LotteryState::clear_code() {
  code_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LotteryState::_internal_code() const {
  return code_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LotteryState::code() const {
  // @@protoc_insertion_point(field_get:pb.LotteryState.Code)
  return _internal_code();
}
inline void LotteryState::_internal_set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  code_ = value;
}
inline void LotteryState::set_code(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:pb.LotteryState.Code)
}

// -------------------------------------------------------------------

// LotteryServer

// string ServerTime = 1;
inline void LotteryServer::clear_servertime() {
  servertime_.ClearToEmpty();
}
inline const std::string& LotteryServer::servertime() const {
  // @@protoc_insertion_point(field_get:pb.LotteryServer.ServerTime)
  return _internal_servertime();
}
inline void LotteryServer::set_servertime(const std::string& value) {
  _internal_set_servertime(value);
  // @@protoc_insertion_point(field_set:pb.LotteryServer.ServerTime)
}
inline std::string* LotteryServer::mutable_servertime() {
  // @@protoc_insertion_point(field_mutable:pb.LotteryServer.ServerTime)
  return _internal_mutable_servertime();
}
inline const std::string& LotteryServer::_internal_servertime() const {
  return servertime_.Get();
}
inline void LotteryServer::_internal_set_servertime(const std::string& value) {
  
  servertime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LotteryServer::set_servertime(std::string&& value) {
  
  servertime_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.LotteryServer.ServerTime)
}
inline void LotteryServer::set_servertime(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  servertime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.LotteryServer.ServerTime)
}
inline void LotteryServer::set_servertime(const char* value,
    size_t size) {
  
  servertime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.LotteryServer.ServerTime)
}
inline std::string* LotteryServer::_internal_mutable_servertime() {
  
  return servertime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LotteryServer::release_servertime() {
  // @@protoc_insertion_point(field_release:pb.LotteryServer.ServerTime)
  return servertime_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LotteryServer::set_allocated_servertime(std::string* servertime) {
  if (servertime != nullptr) {
    
  } else {
    
  }
  servertime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), servertime,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.LotteryServer.ServerTime)
}

// -------------------------------------------------------------------

// LotteryInfo

// string Periods = 1;
inline void LotteryInfo::clear_periods() {
  periods_.ClearToEmpty();
}
inline const std::string& LotteryInfo::periods() const {
  // @@protoc_insertion_point(field_get:pb.LotteryInfo.Periods)
  return _internal_periods();
}
inline void LotteryInfo::set_periods(const std::string& value) {
  _internal_set_periods(value);
  // @@protoc_insertion_point(field_set:pb.LotteryInfo.Periods)
}
inline std::string* LotteryInfo::mutable_periods() {
  // @@protoc_insertion_point(field_mutable:pb.LotteryInfo.Periods)
  return _internal_mutable_periods();
}
inline const std::string& LotteryInfo::_internal_periods() const {
  return periods_.Get();
}
inline void LotteryInfo::_internal_set_periods(const std::string& value) {
  
  periods_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LotteryInfo::set_periods(std::string&& value) {
  
  periods_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.LotteryInfo.Periods)
}
inline void LotteryInfo::set_periods(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  periods_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.LotteryInfo.Periods)
}
inline void LotteryInfo::set_periods(const char* value,
    size_t size) {
  
  periods_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.LotteryInfo.Periods)
}
inline std::string* LotteryInfo::_internal_mutable_periods() {
  
  return periods_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LotteryInfo::release_periods() {
  // @@protoc_insertion_point(field_release:pb.LotteryInfo.Periods)
  return periods_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LotteryInfo::set_allocated_periods(std::string* periods) {
  if (periods != nullptr) {
    
  } else {
    
  }
  periods_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), periods,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.LotteryInfo.Periods)
}

// string BeginTime = 2;
inline void LotteryInfo::clear_begintime() {
  begintime_.ClearToEmpty();
}
inline const std::string& LotteryInfo::begintime() const {
  // @@protoc_insertion_point(field_get:pb.LotteryInfo.BeginTime)
  return _internal_begintime();
}
inline void LotteryInfo::set_begintime(const std::string& value) {
  _internal_set_begintime(value);
  // @@protoc_insertion_point(field_set:pb.LotteryInfo.BeginTime)
}
inline std::string* LotteryInfo::mutable_begintime() {
  // @@protoc_insertion_point(field_mutable:pb.LotteryInfo.BeginTime)
  return _internal_mutable_begintime();
}
inline const std::string& LotteryInfo::_internal_begintime() const {
  return begintime_.Get();
}
inline void LotteryInfo::_internal_set_begintime(const std::string& value) {
  
  begintime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LotteryInfo::set_begintime(std::string&& value) {
  
  begintime_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.LotteryInfo.BeginTime)
}
inline void LotteryInfo::set_begintime(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  begintime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.LotteryInfo.BeginTime)
}
inline void LotteryInfo::set_begintime(const char* value,
    size_t size) {
  
  begintime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.LotteryInfo.BeginTime)
}
inline std::string* LotteryInfo::_internal_mutable_begintime() {
  
  return begintime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LotteryInfo::release_begintime() {
  // @@protoc_insertion_point(field_release:pb.LotteryInfo.BeginTime)
  return begintime_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LotteryInfo::set_allocated_begintime(std::string* begintime) {
  if (begintime != nullptr) {
    
  } else {
    
  }
  begintime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), begintime,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.LotteryInfo.BeginTime)
}

// string OpenTime = 3;
inline void LotteryInfo::clear_opentime() {
  opentime_.ClearToEmpty();
}
inline const std::string& LotteryInfo::opentime() const {
  // @@protoc_insertion_point(field_get:pb.LotteryInfo.OpenTime)
  return _internal_opentime();
}
inline void LotteryInfo::set_opentime(const std::string& value) {
  _internal_set_opentime(value);
  // @@protoc_insertion_point(field_set:pb.LotteryInfo.OpenTime)
}
inline std::string* LotteryInfo::mutable_opentime() {
  // @@protoc_insertion_point(field_mutable:pb.LotteryInfo.OpenTime)
  return _internal_mutable_opentime();
}
inline const std::string& LotteryInfo::_internal_opentime() const {
  return opentime_.Get();
}
inline void LotteryInfo::_internal_set_opentime(const std::string& value) {
  
  opentime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LotteryInfo::set_opentime(std::string&& value) {
  
  opentime_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.LotteryInfo.OpenTime)
}
inline void LotteryInfo::set_opentime(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  opentime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.LotteryInfo.OpenTime)
}
inline void LotteryInfo::set_opentime(const char* value,
    size_t size) {
  
  opentime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.LotteryInfo.OpenTime)
}
inline std::string* LotteryInfo::_internal_mutable_opentime() {
  
  return opentime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LotteryInfo::release_opentime() {
  // @@protoc_insertion_point(field_release:pb.LotteryInfo.OpenTime)
  return opentime_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LotteryInfo::set_allocated_opentime(std::string* opentime) {
  if (opentime != nullptr) {
    
  } else {
    
  }
  opentime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), opentime,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.LotteryInfo.OpenTime)
}

// string CollectTime = 4;
inline void LotteryInfo::clear_collecttime() {
  collecttime_.ClearToEmpty();
}
inline const std::string& LotteryInfo::collecttime() const {
  // @@protoc_insertion_point(field_get:pb.LotteryInfo.CollectTime)
  return _internal_collecttime();
}
inline void LotteryInfo::set_collecttime(const std::string& value) {
  _internal_set_collecttime(value);
  // @@protoc_insertion_point(field_set:pb.LotteryInfo.CollectTime)
}
inline std::string* LotteryInfo::mutable_collecttime() {
  // @@protoc_insertion_point(field_mutable:pb.LotteryInfo.CollectTime)
  return _internal_mutable_collecttime();
}
inline const std::string& LotteryInfo::_internal_collecttime() const {
  return collecttime_.Get();
}
inline void LotteryInfo::_internal_set_collecttime(const std::string& value) {
  
  collecttime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LotteryInfo::set_collecttime(std::string&& value) {
  
  collecttime_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.LotteryInfo.CollectTime)
}
inline void LotteryInfo::set_collecttime(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  collecttime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.LotteryInfo.CollectTime)
}
inline void LotteryInfo::set_collecttime(const char* value,
    size_t size) {
  
  collecttime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.LotteryInfo.CollectTime)
}
inline std::string* LotteryInfo::_internal_mutable_collecttime() {
  
  return collecttime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LotteryInfo::release_collecttime() {
  // @@protoc_insertion_point(field_release:pb.LotteryInfo.CollectTime)
  return collecttime_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LotteryInfo::set_allocated_collecttime(std::string* collecttime) {
  if (collecttime != nullptr) {
    
  } else {
    
  }
  collecttime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), collecttime,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.LotteryInfo.CollectTime)
}

// string OpenContent = 5;
inline void LotteryInfo::clear_opencontent() {
  opencontent_.ClearToEmpty();
}
inline const std::string& LotteryInfo::opencontent() const {
  // @@protoc_insertion_point(field_get:pb.LotteryInfo.OpenContent)
  return _internal_opencontent();
}
inline void LotteryInfo::set_opencontent(const std::string& value) {
  _internal_set_opencontent(value);
  // @@protoc_insertion_point(field_set:pb.LotteryInfo.OpenContent)
}
inline std::string* LotteryInfo::mutable_opencontent() {
  // @@protoc_insertion_point(field_mutable:pb.LotteryInfo.OpenContent)
  return _internal_mutable_opencontent();
}
inline const std::string& LotteryInfo::_internal_opencontent() const {
  return opencontent_.Get();
}
inline void LotteryInfo::_internal_set_opencontent(const std::string& value) {
  
  opencontent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void LotteryInfo::set_opencontent(std::string&& value) {
  
  opencontent_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.LotteryInfo.OpenContent)
}
inline void LotteryInfo::set_opencontent(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  opencontent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.LotteryInfo.OpenContent)
}
inline void LotteryInfo::set_opencontent(const char* value,
    size_t size) {
  
  opencontent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.LotteryInfo.OpenContent)
}
inline std::string* LotteryInfo::_internal_mutable_opencontent() {
  
  return opencontent_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* LotteryInfo::release_opencontent() {
  // @@protoc_insertion_point(field_release:pb.LotteryInfo.OpenContent)
  return opencontent_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LotteryInfo::set_allocated_opencontent(std::string* opencontent) {
  if (opencontent != nullptr) {
    
  } else {
    
  }
  opencontent_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), opencontent,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.LotteryInfo.OpenContent)
}

// -------------------------------------------------------------------

// LotteryList

// repeated .pb.LotteryInfo Lotterys = 1;
inline int LotteryList::_internal_lotterys_size() const {
  return lotterys_.size();
}
inline int LotteryList::lotterys_size() const {
  return _internal_lotterys_size();
}
inline void LotteryList::clear_lotterys() {
  lotterys_.Clear();
}
inline ::pb::LotteryInfo* LotteryList::mutable_lotterys(int index) {
  // @@protoc_insertion_point(field_mutable:pb.LotteryList.Lotterys)
  return lotterys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::LotteryInfo >*
LotteryList::mutable_lotterys() {
  // @@protoc_insertion_point(field_mutable_list:pb.LotteryList.Lotterys)
  return &lotterys_;
}
inline const ::pb::LotteryInfo& LotteryList::_internal_lotterys(int index) const {
  return lotterys_.Get(index);
}
inline const ::pb::LotteryInfo& LotteryList::lotterys(int index) const {
  // @@protoc_insertion_point(field_get:pb.LotteryList.Lotterys)
  return _internal_lotterys(index);
}
inline ::pb::LotteryInfo* LotteryList::_internal_add_lotterys() {
  return lotterys_.Add();
}
inline ::pb::LotteryInfo* LotteryList::add_lotterys() {
  // @@protoc_insertion_point(field_add:pb.LotteryList.Lotterys)
  return _internal_add_lotterys();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::LotteryInfo >&
LotteryList::lotterys() const {
  // @@protoc_insertion_point(field_list:pb.LotteryList.Lotterys)
  return lotterys_;
}

// -------------------------------------------------------------------

// LotteryNext

// .pb.LotteryInfo LotInfo = 1;
inline bool LotteryNext::_internal_has_lotinfo() const {
  return this != internal_default_instance() && lotinfo_ != nullptr;
}
inline bool LotteryNext::has_lotinfo() const {
  return _internal_has_lotinfo();
}
inline void LotteryNext::clear_lotinfo() {
  if (GetArena() == nullptr && lotinfo_ != nullptr) {
    delete lotinfo_;
  }
  lotinfo_ = nullptr;
}
inline const ::pb::LotteryInfo& LotteryNext::_internal_lotinfo() const {
  const ::pb::LotteryInfo* p = lotinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::LotteryInfo&>(
      ::pb::_LotteryInfo_default_instance_);
}
inline const ::pb::LotteryInfo& LotteryNext::lotinfo() const {
  // @@protoc_insertion_point(field_get:pb.LotteryNext.LotInfo)
  return _internal_lotinfo();
}
inline void LotteryNext::unsafe_arena_set_allocated_lotinfo(
    ::pb::LotteryInfo* lotinfo) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lotinfo_);
  }
  lotinfo_ = lotinfo;
  if (lotinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.LotteryNext.LotInfo)
}
inline ::pb::LotteryInfo* LotteryNext::release_lotinfo() {
  
  ::pb::LotteryInfo* temp = lotinfo_;
  lotinfo_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::LotteryInfo* LotteryNext::unsafe_arena_release_lotinfo() {
  // @@protoc_insertion_point(field_release:pb.LotteryNext.LotInfo)
  
  ::pb::LotteryInfo* temp = lotinfo_;
  lotinfo_ = nullptr;
  return temp;
}
inline ::pb::LotteryInfo* LotteryNext::_internal_mutable_lotinfo() {
  
  if (lotinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::LotteryInfo>(GetArena());
    lotinfo_ = p;
  }
  return lotinfo_;
}
inline ::pb::LotteryInfo* LotteryNext::mutable_lotinfo() {
  // @@protoc_insertion_point(field_mutable:pb.LotteryNext.LotInfo)
  return _internal_mutable_lotinfo();
}
inline void LotteryNext::set_allocated_lotinfo(::pb::LotteryInfo* lotinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lotinfo_;
  }
  if (lotinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lotinfo);
    if (message_arena != submessage_arena) {
      lotinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lotinfo, submessage_arena);
    }
    
  } else {
    
  }
  lotinfo_ = lotinfo;
  // @@protoc_insertion_point(field_set_allocated:pb.LotteryNext.LotInfo)
}

// -------------------------------------------------------------------

// LotteryLatest

// .pb.LotteryInfo LotInfo = 1;
inline bool LotteryLatest::_internal_has_lotinfo() const {
  return this != internal_default_instance() && lotinfo_ != nullptr;
}
inline bool LotteryLatest::has_lotinfo() const {
  return _internal_has_lotinfo();
}
inline void LotteryLatest::clear_lotinfo() {
  if (GetArena() == nullptr && lotinfo_ != nullptr) {
    delete lotinfo_;
  }
  lotinfo_ = nullptr;
}
inline const ::pb::LotteryInfo& LotteryLatest::_internal_lotinfo() const {
  const ::pb::LotteryInfo* p = lotinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::LotteryInfo&>(
      ::pb::_LotteryInfo_default_instance_);
}
inline const ::pb::LotteryInfo& LotteryLatest::lotinfo() const {
  // @@protoc_insertion_point(field_get:pb.LotteryLatest.LotInfo)
  return _internal_lotinfo();
}
inline void LotteryLatest::unsafe_arena_set_allocated_lotinfo(
    ::pb::LotteryInfo* lotinfo) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lotinfo_);
  }
  lotinfo_ = lotinfo;
  if (lotinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.LotteryLatest.LotInfo)
}
inline ::pb::LotteryInfo* LotteryLatest::release_lotinfo() {
  
  ::pb::LotteryInfo* temp = lotinfo_;
  lotinfo_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::LotteryInfo* LotteryLatest::unsafe_arena_release_lotinfo() {
  // @@protoc_insertion_point(field_release:pb.LotteryLatest.LotInfo)
  
  ::pb::LotteryInfo* temp = lotinfo_;
  lotinfo_ = nullptr;
  return temp;
}
inline ::pb::LotteryInfo* LotteryLatest::_internal_mutable_lotinfo() {
  
  if (lotinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::LotteryInfo>(GetArena());
    lotinfo_ = p;
  }
  return lotinfo_;
}
inline ::pb::LotteryInfo* LotteryLatest::mutable_lotinfo() {
  // @@protoc_insertion_point(field_mutable:pb.LotteryLatest.LotInfo)
  return _internal_mutable_lotinfo();
}
inline void LotteryLatest::set_allocated_lotinfo(::pb::LotteryInfo* lotinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete lotinfo_;
  }
  if (lotinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(lotinfo);
    if (message_arena != submessage_arena) {
      lotinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lotinfo, submessage_arena);
    }
    
  } else {
    
  }
  lotinfo_ = lotinfo;
  // @@protoc_insertion_point(field_set_allocated:pb.LotteryLatest.LotInfo)
}

// -------------------------------------------------------------------

// LotteryRequest

// int32 Type = 1;
inline void LotteryRequest::clear_type() {
  type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LotteryRequest::_internal_type() const {
  return type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LotteryRequest::type() const {
  // @@protoc_insertion_point(field_get:pb.LotteryRequest.Type)
  return _internal_type();
}
inline void LotteryRequest::_internal_set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  type_ = value;
}
inline void LotteryRequest::set_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pb.LotteryRequest.Type)
}

// -------------------------------------------------------------------

// LotteryResponse

// .pb.LotteryState LotStatus = 1;
inline bool LotteryResponse::_internal_has_lotstatus() const {
  return Data_case() == kLotStatus;
}
inline bool LotteryResponse::has_lotstatus() const {
  return _internal_has_lotstatus();
}
inline void LotteryResponse::set_has_lotstatus() {
  _oneof_case_[0] = kLotStatus;
}
inline void LotteryResponse::clear_lotstatus() {
  if (_internal_has_lotstatus()) {
    if (GetArena() == nullptr) {
      delete Data_.lotstatus_;
    }
    clear_has_Data();
  }
}
inline ::pb::LotteryState* LotteryResponse::release_lotstatus() {
  // @@protoc_insertion_point(field_release:pb.LotteryResponse.LotStatus)
  if (_internal_has_lotstatus()) {
    clear_has_Data();
      ::pb::LotteryState* temp = Data_.lotstatus_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Data_.lotstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::LotteryState& LotteryResponse::_internal_lotstatus() const {
  return _internal_has_lotstatus()
      ? *Data_.lotstatus_
      : reinterpret_cast< ::pb::LotteryState&>(::pb::_LotteryState_default_instance_);
}
inline const ::pb::LotteryState& LotteryResponse::lotstatus() const {
  // @@protoc_insertion_point(field_get:pb.LotteryResponse.LotStatus)
  return _internal_lotstatus();
}
inline ::pb::LotteryState* LotteryResponse::unsafe_arena_release_lotstatus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.LotteryResponse.LotStatus)
  if (_internal_has_lotstatus()) {
    clear_has_Data();
    ::pb::LotteryState* temp = Data_.lotstatus_;
    Data_.lotstatus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LotteryResponse::unsafe_arena_set_allocated_lotstatus(::pb::LotteryState* lotstatus) {
  clear_Data();
  if (lotstatus) {
    set_has_lotstatus();
    Data_.lotstatus_ = lotstatus;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.LotteryResponse.LotStatus)
}
inline ::pb::LotteryState* LotteryResponse::_internal_mutable_lotstatus() {
  if (!_internal_has_lotstatus()) {
    clear_Data();
    set_has_lotstatus();
    Data_.lotstatus_ = CreateMaybeMessage< ::pb::LotteryState >(GetArena());
  }
  return Data_.lotstatus_;
}
inline ::pb::LotteryState* LotteryResponse::mutable_lotstatus() {
  // @@protoc_insertion_point(field_mutable:pb.LotteryResponse.LotStatus)
  return _internal_mutable_lotstatus();
}

// .pb.LotteryServer LotServer = 2;
inline bool LotteryResponse::_internal_has_lotserver() const {
  return Data_case() == kLotServer;
}
inline bool LotteryResponse::has_lotserver() const {
  return _internal_has_lotserver();
}
inline void LotteryResponse::set_has_lotserver() {
  _oneof_case_[0] = kLotServer;
}
inline void LotteryResponse::clear_lotserver() {
  if (_internal_has_lotserver()) {
    if (GetArena() == nullptr) {
      delete Data_.lotserver_;
    }
    clear_has_Data();
  }
}
inline ::pb::LotteryServer* LotteryResponse::release_lotserver() {
  // @@protoc_insertion_point(field_release:pb.LotteryResponse.LotServer)
  if (_internal_has_lotserver()) {
    clear_has_Data();
      ::pb::LotteryServer* temp = Data_.lotserver_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Data_.lotserver_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::LotteryServer& LotteryResponse::_internal_lotserver() const {
  return _internal_has_lotserver()
      ? *Data_.lotserver_
      : reinterpret_cast< ::pb::LotteryServer&>(::pb::_LotteryServer_default_instance_);
}
inline const ::pb::LotteryServer& LotteryResponse::lotserver() const {
  // @@protoc_insertion_point(field_get:pb.LotteryResponse.LotServer)
  return _internal_lotserver();
}
inline ::pb::LotteryServer* LotteryResponse::unsafe_arena_release_lotserver() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.LotteryResponse.LotServer)
  if (_internal_has_lotserver()) {
    clear_has_Data();
    ::pb::LotteryServer* temp = Data_.lotserver_;
    Data_.lotserver_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LotteryResponse::unsafe_arena_set_allocated_lotserver(::pb::LotteryServer* lotserver) {
  clear_Data();
  if (lotserver) {
    set_has_lotserver();
    Data_.lotserver_ = lotserver;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.LotteryResponse.LotServer)
}
inline ::pb::LotteryServer* LotteryResponse::_internal_mutable_lotserver() {
  if (!_internal_has_lotserver()) {
    clear_Data();
    set_has_lotserver();
    Data_.lotserver_ = CreateMaybeMessage< ::pb::LotteryServer >(GetArena());
  }
  return Data_.lotserver_;
}
inline ::pb::LotteryServer* LotteryResponse::mutable_lotserver() {
  // @@protoc_insertion_point(field_mutable:pb.LotteryResponse.LotServer)
  return _internal_mutable_lotserver();
}

// .pb.LotteryList LotList = 3;
inline bool LotteryResponse::_internal_has_lotlist() const {
  return Data_case() == kLotList;
}
inline bool LotteryResponse::has_lotlist() const {
  return _internal_has_lotlist();
}
inline void LotteryResponse::set_has_lotlist() {
  _oneof_case_[0] = kLotList;
}
inline void LotteryResponse::clear_lotlist() {
  if (_internal_has_lotlist()) {
    if (GetArena() == nullptr) {
      delete Data_.lotlist_;
    }
    clear_has_Data();
  }
}
inline ::pb::LotteryList* LotteryResponse::release_lotlist() {
  // @@protoc_insertion_point(field_release:pb.LotteryResponse.LotList)
  if (_internal_has_lotlist()) {
    clear_has_Data();
      ::pb::LotteryList* temp = Data_.lotlist_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Data_.lotlist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::LotteryList& LotteryResponse::_internal_lotlist() const {
  return _internal_has_lotlist()
      ? *Data_.lotlist_
      : reinterpret_cast< ::pb::LotteryList&>(::pb::_LotteryList_default_instance_);
}
inline const ::pb::LotteryList& LotteryResponse::lotlist() const {
  // @@protoc_insertion_point(field_get:pb.LotteryResponse.LotList)
  return _internal_lotlist();
}
inline ::pb::LotteryList* LotteryResponse::unsafe_arena_release_lotlist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.LotteryResponse.LotList)
  if (_internal_has_lotlist()) {
    clear_has_Data();
    ::pb::LotteryList* temp = Data_.lotlist_;
    Data_.lotlist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LotteryResponse::unsafe_arena_set_allocated_lotlist(::pb::LotteryList* lotlist) {
  clear_Data();
  if (lotlist) {
    set_has_lotlist();
    Data_.lotlist_ = lotlist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.LotteryResponse.LotList)
}
inline ::pb::LotteryList* LotteryResponse::_internal_mutable_lotlist() {
  if (!_internal_has_lotlist()) {
    clear_Data();
    set_has_lotlist();
    Data_.lotlist_ = CreateMaybeMessage< ::pb::LotteryList >(GetArena());
  }
  return Data_.lotlist_;
}
inline ::pb::LotteryList* LotteryResponse::mutable_lotlist() {
  // @@protoc_insertion_point(field_mutable:pb.LotteryResponse.LotList)
  return _internal_mutable_lotlist();
}

// .pb.LotteryNext LotNext = 4;
inline bool LotteryResponse::_internal_has_lotnext() const {
  return Data_case() == kLotNext;
}
inline bool LotteryResponse::has_lotnext() const {
  return _internal_has_lotnext();
}
inline void LotteryResponse::set_has_lotnext() {
  _oneof_case_[0] = kLotNext;
}
inline void LotteryResponse::clear_lotnext() {
  if (_internal_has_lotnext()) {
    if (GetArena() == nullptr) {
      delete Data_.lotnext_;
    }
    clear_has_Data();
  }
}
inline ::pb::LotteryNext* LotteryResponse::release_lotnext() {
  // @@protoc_insertion_point(field_release:pb.LotteryResponse.LotNext)
  if (_internal_has_lotnext()) {
    clear_has_Data();
      ::pb::LotteryNext* temp = Data_.lotnext_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Data_.lotnext_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::LotteryNext& LotteryResponse::_internal_lotnext() const {
  return _internal_has_lotnext()
      ? *Data_.lotnext_
      : reinterpret_cast< ::pb::LotteryNext&>(::pb::_LotteryNext_default_instance_);
}
inline const ::pb::LotteryNext& LotteryResponse::lotnext() const {
  // @@protoc_insertion_point(field_get:pb.LotteryResponse.LotNext)
  return _internal_lotnext();
}
inline ::pb::LotteryNext* LotteryResponse::unsafe_arena_release_lotnext() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.LotteryResponse.LotNext)
  if (_internal_has_lotnext()) {
    clear_has_Data();
    ::pb::LotteryNext* temp = Data_.lotnext_;
    Data_.lotnext_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LotteryResponse::unsafe_arena_set_allocated_lotnext(::pb::LotteryNext* lotnext) {
  clear_Data();
  if (lotnext) {
    set_has_lotnext();
    Data_.lotnext_ = lotnext;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.LotteryResponse.LotNext)
}
inline ::pb::LotteryNext* LotteryResponse::_internal_mutable_lotnext() {
  if (!_internal_has_lotnext()) {
    clear_Data();
    set_has_lotnext();
    Data_.lotnext_ = CreateMaybeMessage< ::pb::LotteryNext >(GetArena());
  }
  return Data_.lotnext_;
}
inline ::pb::LotteryNext* LotteryResponse::mutable_lotnext() {
  // @@protoc_insertion_point(field_mutable:pb.LotteryResponse.LotNext)
  return _internal_mutable_lotnext();
}

// .pb.LotteryLatest LotLatest = 5;
inline bool LotteryResponse::_internal_has_lotlatest() const {
  return Data_case() == kLotLatest;
}
inline bool LotteryResponse::has_lotlatest() const {
  return _internal_has_lotlatest();
}
inline void LotteryResponse::set_has_lotlatest() {
  _oneof_case_[0] = kLotLatest;
}
inline void LotteryResponse::clear_lotlatest() {
  if (_internal_has_lotlatest()) {
    if (GetArena() == nullptr) {
      delete Data_.lotlatest_;
    }
    clear_has_Data();
  }
}
inline ::pb::LotteryLatest* LotteryResponse::release_lotlatest() {
  // @@protoc_insertion_point(field_release:pb.LotteryResponse.LotLatest)
  if (_internal_has_lotlatest()) {
    clear_has_Data();
      ::pb::LotteryLatest* temp = Data_.lotlatest_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    Data_.lotlatest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::LotteryLatest& LotteryResponse::_internal_lotlatest() const {
  return _internal_has_lotlatest()
      ? *Data_.lotlatest_
      : reinterpret_cast< ::pb::LotteryLatest&>(::pb::_LotteryLatest_default_instance_);
}
inline const ::pb::LotteryLatest& LotteryResponse::lotlatest() const {
  // @@protoc_insertion_point(field_get:pb.LotteryResponse.LotLatest)
  return _internal_lotlatest();
}
inline ::pb::LotteryLatest* LotteryResponse::unsafe_arena_release_lotlatest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.LotteryResponse.LotLatest)
  if (_internal_has_lotlatest()) {
    clear_has_Data();
    ::pb::LotteryLatest* temp = Data_.lotlatest_;
    Data_.lotlatest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LotteryResponse::unsafe_arena_set_allocated_lotlatest(::pb::LotteryLatest* lotlatest) {
  clear_Data();
  if (lotlatest) {
    set_has_lotlatest();
    Data_.lotlatest_ = lotlatest;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.LotteryResponse.LotLatest)
}
inline ::pb::LotteryLatest* LotteryResponse::_internal_mutable_lotlatest() {
  if (!_internal_has_lotlatest()) {
    clear_Data();
    set_has_lotlatest();
    Data_.lotlatest_ = CreateMaybeMessage< ::pb::LotteryLatest >(GetArena());
  }
  return Data_.lotlatest_;
}
inline ::pb::LotteryLatest* LotteryResponse::mutable_lotlatest() {
  // @@protoc_insertion_point(field_mutable:pb.LotteryResponse.LotLatest)
  return _internal_mutable_lotlatest();
}

inline bool LotteryResponse::has_Data() const {
  return Data_case() != DATA_NOT_SET;
}
inline void LotteryResponse::clear_has_Data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline LotteryResponse::DataCase LotteryResponse::Data_case() const {
  return LotteryResponse::DataCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_br_2eproto
