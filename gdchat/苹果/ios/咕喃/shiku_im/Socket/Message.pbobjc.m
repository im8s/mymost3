// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Message.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - MessageRoot

@implementation MessageRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - MessageRoot_FileDescriptor

static GPBFileDescriptor *MessageRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"Message"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - MessageHead

@implementation MessageHead

@dynamic from;
@dynamic to;
@dynamic messageId;
@dynamic chatType;
@dynamic offline;

typedef struct MessageHead__storage_ {
  uint32_t _has_storage_[1];
  int32_t chatType;
  NSString *from;
  NSString *to;
  NSString *messageId;
} MessageHead__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = MessageHead_FieldNumber_From,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageHead__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "to",
        .dataTypeSpecific.className = NULL,
        .number = MessageHead_FieldNumber_To,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageHead__storage_, to),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = MessageHead_FieldNumber_MessageId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageHead__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatType",
        .dataTypeSpecific.className = NULL,
        .number = MessageHead_FieldNumber_ChatType,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MessageHead__storage_, chatType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "offline",
        .dataTypeSpecific.className = NULL,
        .number = MessageHead_FieldNumber_Offline,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageHead class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageHead__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\t\000\004\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChatMessage

@implementation ChatMessage

@dynamic hasMessageHead, messageHead;
@dynamic fromUserId;
@dynamic fromUserName;
@dynamic toUserId;
@dynamic toUserName;
@dynamic timeSend;
@dynamic type;
@dynamic content;
@dynamic objectId;
@dynamic fileName;
@dynamic isEncrypt;
@dynamic deleteTime;
@dynamic isReadDel;
@dynamic fileSize;
@dynamic fileTime;
@dynamic locationX;
@dynamic locationY;
@dynamic encryptType;
@dynamic signature;
@dynamic other;

typedef struct ChatMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  int32_t encryptType;
  MessageHead *messageHead;
  NSString *fromUserId;
  NSString *fromUserName;
  NSString *toUserId;
  NSString *toUserName;
  NSString *content;
  NSString *objectId;
  NSString *fileName;
  NSString *signature;
  NSString *other;
  int64_t timeSend;
  int64_t deleteTime;
  int64_t fileSize;
  int64_t fileTime;
  double locationX;
  double locationY;
} ChatMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageHead",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHead),
        .number = ChatMessage_FieldNumber_MessageHead,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, messageHead),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "fromUserId",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_FromUserId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, fromUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fromUserName",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_FromUserName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, fromUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "toUserId",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_ToUserId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, toUserId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "toUserName",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_ToUserName,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, toUserName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timeSend",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_TimeSend,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, timeSend),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_Type,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_Content,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "objectId",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_ObjectId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, objectId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fileName",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_FileName,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, fileName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isEncrypt",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_IsEncrypt,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "deleteTime",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_DeleteTime,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, deleteTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isReadDel",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_IsReadDel,
        .hasIndex = 13,
        .offset = 14,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fileSize",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_FileSize,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, fileSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "fileTime",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_FileTime,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, fileTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "locationX",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_LocationX,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, locationX),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "locationY",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_LocationY,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, locationY),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "encryptType",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_EncryptType,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, encryptType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_Signature,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "other",
        .dataTypeSpecific.className = NULL,
        .number = ChatMessage_FieldNumber_Other,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(ChatMessage__storage_, other),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChatMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChatMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\016\001\013\000\002\n\000\003\014\000\004\010\000\005\n\000\006\010\000\t\010\000\n\010\000\013\t\000\014\n\000\r\t\000\016\010\000\017\010\000"
        "\022\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthMessage

@implementation AuthMessage

@dynamic hasMessageHead, messageHead;
@dynamic token;
@dynamic password;
@dynamic deviceId;

typedef struct AuthMessage__storage_ {
  uint32_t _has_storage_[1];
  MessageHead *messageHead;
  NSString *token;
  NSString *password;
  NSString *deviceId;
} AuthMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageHead",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHead),
        .number = AuthMessage_FieldNumber_MessageHead,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthMessage__storage_, messageHead),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = AuthMessage_FieldNumber_Token,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuthMessage__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "password",
        .dataTypeSpecific.className = NULL,
        .number = AuthMessage_FieldNumber_Password,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthMessage__storage_, password),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = AuthMessage_FieldNumber_DeviceId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AuthMessage__storage_, deviceId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthMessage class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\013\000\004\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AuthRespMessageProBuf

@implementation AuthRespMessageProBuf

@dynamic hasMessageHead, messageHead;
@dynamic status;
@dynamic arg;
@dynamic token;
@dynamic resources;

typedef struct AuthRespMessageProBuf__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  MessageHead *messageHead;
  NSString *arg;
  NSString *token;
  NSString *resources;
} AuthRespMessageProBuf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageHead",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHead),
        .number = AuthRespMessageProBuf_FieldNumber_MessageHead,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AuthRespMessageProBuf__storage_, messageHead),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = AuthRespMessageProBuf_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AuthRespMessageProBuf__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "arg",
        .dataTypeSpecific.className = NULL,
        .number = AuthRespMessageProBuf_FieldNumber_Arg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AuthRespMessageProBuf__storage_, arg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "token",
        .dataTypeSpecific.className = NULL,
        .number = AuthRespMessageProBuf_FieldNumber_Token,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(AuthRespMessageProBuf__storage_, token),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "resources",
        .dataTypeSpecific.className = NULL,
        .number = AuthRespMessageProBuf_FieldNumber_Resources,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(AuthRespMessageProBuf__storage_, resources),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AuthRespMessageProBuf class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AuthRespMessageProBuf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - MessageReceiptStatusProBuf

@implementation MessageReceiptStatusProBuf

@dynamic hasMessageHead, messageHead;
@dynamic status;
@dynamic messageId;

typedef struct MessageReceiptStatusProBuf__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  MessageHead *messageHead;
  NSString *messageId;
} MessageReceiptStatusProBuf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageHead",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHead),
        .number = MessageReceiptStatusProBuf_FieldNumber_MessageHead,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MessageReceiptStatusProBuf__storage_, messageHead),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = MessageReceiptStatusProBuf_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MessageReceiptStatusProBuf__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = MessageReceiptStatusProBuf_FieldNumber_MessageId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MessageReceiptStatusProBuf__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MessageReceiptStatusProBuf class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MessageReceiptStatusProBuf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\013\000\003\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - JoinGroupMessageProBuf

@implementation JoinGroupMessageProBuf

@dynamic hasMessageHead, messageHead;
@dynamic jid;
@dynamic seconds;

typedef struct JoinGroupMessageProBuf__storage_ {
  uint32_t _has_storage_[1];
  MessageHead *messageHead;
  NSString *jid;
  int64_t seconds;
} JoinGroupMessageProBuf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageHead",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHead),
        .number = JoinGroupMessageProBuf_FieldNumber_MessageHead,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(JoinGroupMessageProBuf__storage_, messageHead),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "jid",
        .dataTypeSpecific.className = NULL,
        .number = JoinGroupMessageProBuf_FieldNumber_Jid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(JoinGroupMessageProBuf__storage_, jid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "seconds",
        .dataTypeSpecific.className = NULL,
        .number = JoinGroupMessageProBuf_FieldNumber_Seconds,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(JoinGroupMessageProBuf__storage_, seconds),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[JoinGroupMessageProBuf class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(JoinGroupMessageProBuf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ExitGroupMessageProBuf

@implementation ExitGroupMessageProBuf

@dynamic hasMessageHead, messageHead;
@dynamic jid;

typedef struct ExitGroupMessageProBuf__storage_ {
  uint32_t _has_storage_[1];
  MessageHead *messageHead;
  NSString *jid;
} ExitGroupMessageProBuf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageHead",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHead),
        .number = ExitGroupMessageProBuf_FieldNumber_MessageHead,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ExitGroupMessageProBuf__storage_, messageHead),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "jid",
        .dataTypeSpecific.className = NULL,
        .number = ExitGroupMessageProBuf_FieldNumber_Jid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ExitGroupMessageProBuf__storage_, jid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ExitGroupMessageProBuf class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ExitGroupMessageProBuf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GroupMessageRespProBuf

@implementation GroupMessageRespProBuf

@dynamic hasMessageHead, messageHead;
@dynamic jid;
@dynamic status;
@dynamic isExit;

typedef struct GroupMessageRespProBuf__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  MessageHead *messageHead;
  NSString *jid;
} GroupMessageRespProBuf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageHead",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHead),
        .number = GroupMessageRespProBuf_FieldNumber_MessageHead,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GroupMessageRespProBuf__storage_, messageHead),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "jid",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessageRespProBuf_FieldNumber_Jid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GroupMessageRespProBuf__storage_, jid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessageRespProBuf_FieldNumber_Status,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GroupMessageRespProBuf__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isExit",
        .dataTypeSpecific.className = NULL,
        .number = GroupMessageRespProBuf_FieldNumber_IsExit,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GroupMessageRespProBuf class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GroupMessageRespProBuf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\013\000\004\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PullMessageHistoryRecordReqProBuf

@implementation PullMessageHistoryRecordReqProBuf

@dynamic hasMessageHead, messageHead;
@dynamic jid;
@dynamic size;
@dynamic startTime;
@dynamic endTime;

typedef struct PullMessageHistoryRecordReqProBuf__storage_ {
  uint32_t _has_storage_[1];
  int32_t size;
  MessageHead *messageHead;
  NSString *jid;
  int64_t startTime;
  int64_t endTime;
} PullMessageHistoryRecordReqProBuf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageHead",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHead),
        .number = PullMessageHistoryRecordReqProBuf_FieldNumber_MessageHead,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PullMessageHistoryRecordReqProBuf__storage_, messageHead),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "jid",
        .dataTypeSpecific.className = NULL,
        .number = PullMessageHistoryRecordReqProBuf_FieldNumber_Jid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PullMessageHistoryRecordReqProBuf__storage_, jid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "size",
        .dataTypeSpecific.className = NULL,
        .number = PullMessageHistoryRecordReqProBuf_FieldNumber_Size,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PullMessageHistoryRecordReqProBuf__storage_, size),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "startTime",
        .dataTypeSpecific.className = NULL,
        .number = PullMessageHistoryRecordReqProBuf_FieldNumber_StartTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PullMessageHistoryRecordReqProBuf__storage_, startTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PullMessageHistoryRecordReqProBuf_FieldNumber_EndTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(PullMessageHistoryRecordReqProBuf__storage_, endTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PullMessageHistoryRecordReqProBuf class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PullMessageHistoryRecordReqProBuf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\013\000\004\t\000\005\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PullMessageHistoryRecordRespProBuf

@implementation PullMessageHistoryRecordRespProBuf

@dynamic messageId;
@dynamic jid;
@dynamic chatType;
@dynamic messageListArray, messageListArray_Count;
@dynamic count;

typedef struct PullMessageHistoryRecordRespProBuf__storage_ {
  uint32_t _has_storage_[1];
  int32_t chatType;
  int32_t count;
  NSString *messageId;
  NSString *jid;
  NSMutableArray *messageListArray;
} PullMessageHistoryRecordRespProBuf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = PullMessageHistoryRecordRespProBuf_FieldNumber_MessageId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PullMessageHistoryRecordRespProBuf__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jid",
        .dataTypeSpecific.className = NULL,
        .number = PullMessageHistoryRecordRespProBuf_FieldNumber_Jid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PullMessageHistoryRecordRespProBuf__storage_, jid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "chatType",
        .dataTypeSpecific.className = NULL,
        .number = PullMessageHistoryRecordRespProBuf_FieldNumber_ChatType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PullMessageHistoryRecordRespProBuf__storage_, chatType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "messageListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatMessage),
        .number = PullMessageHistoryRecordRespProBuf_FieldNumber_MessageListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PullMessageHistoryRecordRespProBuf__storage_, messageListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = PullMessageHistoryRecordRespProBuf_FieldNumber_Count,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(PullMessageHistoryRecordRespProBuf__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PullMessageHistoryRecordRespProBuf class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PullMessageHistoryRecordRespProBuf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\t\000\003\010\000\004\000messageList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PullBatchGroupMessageReqProBuf

@implementation PullBatchGroupMessageReqProBuf

@dynamic hasMessageHead, messageHead;
@dynamic jidListArray, jidListArray_Count;
@dynamic endTime;

typedef struct PullBatchGroupMessageReqProBuf__storage_ {
  uint32_t _has_storage_[1];
  MessageHead *messageHead;
  NSMutableArray *jidListArray;
  int64_t endTime;
} PullBatchGroupMessageReqProBuf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageHead",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHead),
        .number = PullBatchGroupMessageReqProBuf_FieldNumber_MessageHead,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PullBatchGroupMessageReqProBuf__storage_, messageHead),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "jidListArray",
        .dataTypeSpecific.className = NULL,
        .number = PullBatchGroupMessageReqProBuf_FieldNumber_JidListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PullBatchGroupMessageReqProBuf__storage_, jidListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "endTime",
        .dataTypeSpecific.className = NULL,
        .number = PullBatchGroupMessageReqProBuf_FieldNumber_EndTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PullBatchGroupMessageReqProBuf__storage_, endTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PullBatchGroupMessageReqProBuf class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PullBatchGroupMessageReqProBuf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001\013\000\002\000jidList\000\003\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PullGroupMessageRespProBuf

@implementation PullGroupMessageRespProBuf

@dynamic messageId;
@dynamic jid;
@dynamic count;
@dynamic messageListArray, messageListArray_Count;

typedef struct PullGroupMessageRespProBuf__storage_ {
  uint32_t _has_storage_[1];
  NSString *messageId;
  NSString *jid;
  NSMutableArray *messageListArray;
  int64_t count;
} PullGroupMessageRespProBuf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageId",
        .dataTypeSpecific.className = NULL,
        .number = PullGroupMessageRespProBuf_FieldNumber_MessageId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PullGroupMessageRespProBuf__storage_, messageId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jid",
        .dataTypeSpecific.className = NULL,
        .number = PullGroupMessageRespProBuf_FieldNumber_Jid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PullGroupMessageRespProBuf__storage_, jid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = PullGroupMessageRespProBuf_FieldNumber_Count,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PullGroupMessageRespProBuf__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "messageListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChatMessage),
        .number = PullGroupMessageRespProBuf_FieldNumber_MessageListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(PullGroupMessageRespProBuf__storage_, messageListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PullGroupMessageRespProBuf class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PullGroupMessageRespProBuf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\004\000messageList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - PingMessageProBuf

@implementation PingMessageProBuf

@dynamic hasMessageHead, messageHead;

typedef struct PingMessageProBuf__storage_ {
  uint32_t _has_storage_[1];
  MessageHead *messageHead;
} PingMessageProBuf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageHead",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHead),
        .number = PingMessageProBuf_FieldNumber_MessageHead,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PingMessageProBuf__storage_, messageHead),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PingMessageProBuf class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PingMessageProBuf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CommonSuccessProBuf

@implementation CommonSuccessProBuf

@dynamic hasMessageHead, messageHead;

typedef struct CommonSuccessProBuf__storage_ {
  uint32_t _has_storage_[1];
  MessageHead *messageHead;
} CommonSuccessProBuf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageHead",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHead),
        .number = CommonSuccessProBuf_FieldNumber_MessageHead,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CommonSuccessProBuf__storage_, messageHead),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CommonSuccessProBuf class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CommonSuccessProBuf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CommonErrorProBuf

@implementation CommonErrorProBuf

@dynamic hasMessageHead, messageHead;
@dynamic code;
@dynamic arg;

typedef struct CommonErrorProBuf__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  MessageHead *messageHead;
  NSString *arg;
} CommonErrorProBuf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageHead",
        .dataTypeSpecific.className = GPBStringifySymbol(MessageHead),
        .number = CommonErrorProBuf_FieldNumber_MessageHead,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CommonErrorProBuf__storage_, messageHead),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = CommonErrorProBuf_FieldNumber_Code,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CommonErrorProBuf__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "arg",
        .dataTypeSpecific.className = NULL,
        .number = CommonErrorProBuf_FieldNumber_Arg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CommonErrorProBuf__storage_, arg),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CommonErrorProBuf class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CommonErrorProBuf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServerReqMessageProBuf

@implementation ServerReqMessageProBuf

@dynamic type;
@dynamic content;

typedef struct ServerReqMessageProBuf__storage_ {
  uint32_t _has_storage_[1];
  int32_t type;
  NSString *content;
} ServerReqMessageProBuf__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = ServerReqMessageProBuf_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServerReqMessageProBuf__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "content",
        .dataTypeSpecific.className = NULL,
        .number = ServerReqMessageProBuf_FieldNumber_Content,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ServerReqMessageProBuf__storage_, content),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServerReqMessageProBuf class]
                                     rootClass:[MessageRoot class]
                                          file:MessageRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServerReqMessageProBuf__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
